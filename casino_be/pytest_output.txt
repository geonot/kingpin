============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-8.4.0, pluggy-1.6.0
rootdir: /app/casino_be
configfile: pytest.ini
plugins: cov-6.1.1
collected 126 items

tests/test_api.py .......FFFFFFFFFF.FF                                   [ 15%]
tests/test_baccarat_api.py FFFFFFFFFF                                    [ 23%]
tests/test_baccarat_helper.py FF.....F..                                 [ 31%]
tests/test_multiway_helper.py FFFF                                       [ 34%]
tests/test_plinko_helper.py ........                                     [ 41%]
tests/test_poker_actions.py ...F.........FFFFFFFF                        [ 57%]
tests/test_poker_flow.py ......                                          [ 62%]
tests/test_poker_pot_distribution.py FFF                                 [ 65%]
tests/test_poker_validation.py ...................                       [ 80%]
tests/test_slot_tester.py FFF.FF.                                        [ 85%]
tests/test_spin_handler.py FF.FFFFFFF.F                                  [ 95%]
tests/test_utils.py sFF..F                                               [100%]

=================================== FAILURES ===================================
_________________ GameApiTests.test_spin_insufficient_balance __________________

self = <tests.test_api.GameApiTests testMethod=test_spin_insufficient_balance>

    def test_spin_insufficient_balance(self):
        """Test spin attempt with insufficient balance."""
        token = self._login_and_get_token(username="pooruser", password="poorpassword")

        # Set user balance
        with self.app.app_context():
            user = User.query.filter_by(username="pooruser").first()
            self.assertIsNotNone(user)
            user.balance = 5 # Only 5 satoshis
            db.session.commit()

        slot_id = self._create_slot(name="Another Slot", short_name="spin_insuf_slot") # Get slot_id with unique short_name
        with self.app.app_context():
            # Fetch user and slot within the current session context
            user_for_session = User.query.filter_by(username="pooruser").first()
            slot_for_session = Slot.query.get(slot_id)
            self.assertIsNotNone(user_for_session, "User for session not found")
            self.assertIsNotNone(slot_for_session, "Slot for session not found")

            game_session = GameSession(user_id=user_for_session.id, slot_id=slot_for_session.id, game_type="slot", session_start=datetime.now(timezone.utc))
            db.session.add(game_session)
            db.session.commit()

        bet_amount_sats = 10 # Bet 10 satoshis
        spin_payload = {"bet_amount": bet_amount_sats}
        response = self.client.post('/api/slots/spin',
                                     headers={'Authorization': f'Bearer {token}'},
                                     json=spin_payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 400) # Bad Request or 402 Payment Required
E       AssertionError: 422 != 400

tests/test_api.py:388: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:02,452", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: pooruser (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: pooruser (ID: 1)
________________________ GameApiTests.test_spin_success ________________________

self = <tests.test_api.GameApiTests testMethod=test_spin_success>

    def test_spin_success(self):
        """Test a successful spin."""
        token = self._login_and_get_token(username="spinner", password="spinpassword")

        # Get user for balance update
        with self.app.app_context():
            user = User.query.filter_by(username="spinner").first()
            self.assertIsNotNone(user)
            user.balance = 1000 * Config.SATOSHI_FACTOR # Give user 1000 BTC in satoshis
            db.session.commit()
            db.session.refresh(user)
            original_balance = user.balance

        # Create a slot machine
        slot_id = self._create_slot(short_name="spin_succ_slot") # Get slot_id with unique short_name

        with self.app.app_context():
            # Fetch user and slot within the current session context to avoid DetachedInstanceError
            user_for_session = User.query.filter_by(username="spinner").first() # User from _login_and_get_token
            slot_for_session = Slot.query.get(slot_id)
            self.assertIsNotNone(user_for_session, "User for session not found")
            self.assertIsNotNone(slot_for_session, "Slot for session not found")

            # Ensure user has balance (already done in _login_and_get_token's user creation, but good to be explicit if needed)
            # For this test, user's balance is set after _login_and_get_token call.
            original_balance = user_for_session.balance


            game_session = GameSession(user_id=user_for_session.id, slot_id=slot_for_session.id, game_type="slot", session_start=datetime.now(timezone.utc))
            db.session.add(game_session)
            db.session.commit()

        bet_amount_sats = 10 * Config.SATOSHI_FACTOR # Bet 10 BTC in satoshis

        spin_payload = {"bet_amount": bet_amount_sats}
        response = self.client.post('/api/slots/spin',
                                     headers={'Authorization': f'Bearer {token}'},
                                     json=spin_payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 200, f"Spin failed: {data.get('status_message')}")
E       AssertionError: 422 != 200 : Spin failed: None

tests/test_api.py:344: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:02,686", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: spinner (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: spinner (ID: 1)
_____________ BillingApiTests.test_deposit_fail_invalid_bonus_code _____________

self = <tests.test_api.BillingApiTests testMethod=test_deposit_fail_invalid_bonus_code>

    def test_deposit_fail_invalid_bonus_code(self):
        token, user_id = self._login_and_get_token(username="deposit_invalid_bonus_user")

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = 1000
            db.session.commit()
            initial_balance = user.balance

        deposit_amount = 500
        payload = {"deposit_amount_sats": deposit_amount, "bonus_code": "NONEXISTENTCODE"}

        response = self.client.post('/api/deposit', headers={'Authorization': f'Bearer {token}'}, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 200) # Deposit is successful, bonus fails
E       AssertionError: 422 != 200

tests/test_api.py:521: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:02,868", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: deposit_invalid_bonus_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: deposit_invalid_bonus_user (ID: 1)
________________ BillingApiTests.test_deposit_success_no_bonus _________________

self = <tests.test_api.BillingApiTests testMethod=test_deposit_success_no_bonus>

    def test_deposit_success_no_bonus(self):
        token, user_id = self._login_and_get_token(username="deposit_no_bonus_user")

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = 1000 # Initial balance in satoshis
            db.session.commit()
            initial_balance = user.balance

        deposit_amount = 500
        payload = {"deposit_amount_sats": deposit_amount}

        response = self.client.post('/api/deposit', headers={'Authorization': f'Bearer {token}'}, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 200, data.get('status_message'))
E       AssertionError: 422 != 200

tests/test_api.py:423: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:03,021", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: deposit_no_bonus_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: deposit_no_bonus_user (ID: 1)
_________ BillingApiTests.test_deposit_success_with_valid_fixed_bonus __________

self = <tests.test_api.BillingApiTests testMethod=test_deposit_success_with_valid_fixed_bonus>

    def test_deposit_success_with_valid_fixed_bonus(self):
        token, user_id = self._login_and_get_token(username="deposit_fixed_bonus_user")
        fixed_bonus_sats = 10000
        bonus_code_obj = self._create_bonus_code(code_id="FIXED10K", type="deposit", subtype="fixed", amount=None, amount_sats=fixed_bonus_sats, wagering_multiplier=25)

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = 5000 # Initial balance
            db.session.commit()
            initial_balance = user.balance

        deposit_amount = 20000
        payload = {"deposit_amount_sats": deposit_amount, "bonus_code": bonus_code_obj.code_id}

        response = self.client.post('/api/deposit', headers={'Authorization': f'Bearer {token}'}, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 200, data.get('status_message'))
E       AssertionError: 422 != 200

tests/test_api.py:490: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:03,222", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: deposit_fixed_bonus_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: deposit_fixed_bonus_user (ID: 1)
_______ BillingApiTests.test_deposit_success_with_valid_percentage_bonus _______

self = <tests.test_api.BillingApiTests testMethod=test_deposit_success_with_valid_percentage_bonus>

    def test_deposit_success_with_valid_percentage_bonus(self):
        token, user_id = self._login_and_get_token(username="deposit_perc_bonus_user")
        bonus_code_obj = self._create_bonus_code(code_id="PERC50", type="deposit", subtype="percentage", amount=50.0, wagering_multiplier=20) # 50% bonus

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = 1000 # Initial balance
            db.session.commit()
            initial_balance = user.balance

        deposit_amount = 1000
        expected_bonus_amount = int(deposit_amount * 0.50)
        payload = {"deposit_amount_sats": deposit_amount, "bonus_code": bonus_code_obj.code_id}

        response = self.client.post('/api/deposit', headers={'Authorization': f'Bearer {token}'}, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 200, data.get('status_message'))
E       AssertionError: 422 != 200

tests/test_api.py:452: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:03,382", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: deposit_perc_bonus_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: deposit_perc_bonus_user (ID: 1)
_____ BillingApiTests.test_withdraw_fail_active_bonus_wagering_incomplete ______

self = <tests.test_api.BillingApiTests testMethod=test_withdraw_fail_active_bonus_wagering_incomplete>

    def test_withdraw_fail_active_bonus_wagering_incomplete(self):
        token, user_id = self._login_and_get_token(username="withdraw_wagering_user")
        bonus_code_obj = self._create_bonus_code(code_id="WAGERBONUS", type="deposit", subtype="fixed", amount_sats=500, wagering_multiplier=10)

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = 2000 # Sufficient balance for withdrawal itself

            # Create an active UserBonus with incomplete wagering
            user_bonus = UserBonus(
                user_id=user.id,
                bonus_code_id=bonus_code_obj.id,
                bonus_amount_awarded_sats=500,
>               wagering_requirement_multiplier=bonus_code_obj.wagering_requirement_multiplier,
                wagering_requirement_sats= (500 + 500) * bonus_code_obj.wagering_requirement_multiplier, # Example calculation
                wagering_progress_sats=100,
                is_active=True,
                is_completed=False,
                is_cancelled=False,
                activated_at=datetime.now(timezone.utc)
            )
E           AttributeError: 'BonusCode' object has no attribute 'wagering_requirement_multiplier'

tests/test_api.py:587: AttributeError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:03,539", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: withdraw_wagering_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: withdraw_wagering_user (ID: 1)
____________ BillingApiTests.test_withdraw_fail_insufficient_funds _____________

self = <tests.test_api.BillingApiTests testMethod=test_withdraw_fail_insufficient_funds>

    def test_withdraw_fail_insufficient_funds(self):
        token, user_id = self._login_and_get_token(username="withdraw_insufficient_user")

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = 50 # Initial balance
            db.session.commit()

        payload = {"amount_sats": 100, "withdraw_wallet_address": "test_btc_address"}
        response = self.client.post('/api/withdraw', headers={'Authorization': f'Bearer {token}'}, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 400, data.get('status_message')) # API returns 400 for this
E       AssertionError: 422 != 400

tests/test_api.py:570: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:03,690", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: withdraw_insufficient_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: withdraw_insufficient_user (ID: 1)
____________________ BillingApiTests.test_withdraw_success _____________________

self = <tests.test_api.BillingApiTests testMethod=test_withdraw_success>

    def test_withdraw_success(self):
        token, user_id = self._login_and_get_token(username="withdraw_success_user")
        withdraw_amount = 100

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = 1000 # Initial balance
            db.session.commit()
            initial_balance = user.balance

        payload = {"amount_sats": withdraw_amount, "withdraw_wallet_address": "test_btc_address_valid"}
        response = self.client.post('/api/withdraw', headers={'Authorization': f'Bearer {token}'}, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 201, data.get('status_message'))
E       AssertionError: 422 != 201

tests/test_api.py:546: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:03,842", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: withdraw_success_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: withdraw_success_user (ID: 1)
______________ PlinkoApiTests.test_plinko_play_insufficient_funds ______________

self = <tests.test_api.PlinkoApiTests testMethod=test_plinko_play_insufficient_funds>

    def test_plinko_play_insufficient_funds(self):
        headers, user_id = self._get_auth_headers(username="plinko_poor_user")

        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = int(0.5 * self.SATOSHIS_PER_UNIT) # 0.5 units
            db.session.commit()

        payload = {
            "stake_amount": 1.0, # Trying to bet 1 unit
            "chosen_stake_label": 'Low',
            "slot_landed_label": '0.5x'
        }
        response = self.client.post('/api/plinko/play', headers=headers, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 400)
E       AssertionError: 422 != 400

tests/test_api.py:699: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:04,008", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: plinko_poor_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: plinko_poor_user (ID: 1)
___________________ PlinkoApiTests.test_plinko_play_success ____________________

self = <tests.test_api.PlinkoApiTests testMethod=test_plinko_play_success>

    def test_plinko_play_success(self):
        headers, user_id = self._get_auth_headers()

        initial_balance_units = 100.0
        with self.app.app_context():
            user = User.query.get(user_id)
            user.balance = int(initial_balance_units * self.SATOSHIS_PER_UNIT)
            db.session.commit()

        stake_amount_units = 1.0 # e.g. 1 BTC
        chosen_stake_label = 'Low' # Must match STAKE_CONFIG in plinko_helper
        slot_landed_label = '2x'    # Must match PAYOUT_MULTIPLIERS

        payload = {
            "stake_amount": stake_amount_units,
            "chosen_stake_label": chosen_stake_label,
            "slot_landed_label": slot_landed_label
        }
        response = self.client.post('/api/plinko/play', headers=headers, json=payload)
        data = json.loads(response.data.decode())

>       self.assertEqual(response.status_code, 200, data.get('error') or data.get('message'))
E       AssertionError: 422 != 200

tests/test_api.py:646: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:04,216", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: plinko_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: plinko_user (ID: 1)
______________ PlinkoApiTests.test_plinko_play_validation_errors _______________

self = <tests.test_api.PlinkoApiTests testMethod=test_plinko_play_validation_errors>

    def test_plinko_play_validation_errors(self):
        headers, user_id = self._get_auth_headers(username="plinko_validation_user")
        with self.app.app_context(): # Ensure user has some balance
            user = User.query.get(user_id)
            user.balance = int(10 * self.SATOSHIS_PER_UNIT)
            db.session.commit()

        test_cases = [
            ({"chosen_stake_label": "Low", "slot_landed_label": "2x"}, "stake_amount", 400, "Validation failed"), # Missing stake_amount
            ({"stake_amount": 1.0, "slot_landed_label": "2x"}, "chosen_stake_label", 400, "Validation failed"),    # Missing chosen_stake_label
            ({"stake_amount": 1.0, "chosen_stake_label": "Low"}, "slot_landed_label", 400, "Validation failed"), # Missing slot_landed_label
            ({"stake_amount": 1.0, "chosen_stake_label": "InvalidTier", "slot_landed_label": "2x"}, "error", 400, "Invalid stake label"), # Invalid stake tier
            ({"stake_amount": 0.05, "chosen_stake_label": "Low", "slot_landed_label": "2x"}, "error", 400, "out of range for Low tier"), # Stake too low for tier
            ({"stake_amount": 1.0, "chosen_stake_label": "Low", "slot_landed_label": "100x"}, "error", 400, "Invalid slot landed label"), # Invalid slot
        ]

        for payload, error_key, expected_status, expected_message_part in test_cases:
            with self.subTest(payload=payload):
                response = self.client.post('/api/plinko/play', headers=headers, json=payload)
                data = json.loads(response.data.decode())
>               self.assertEqual(response.status_code, expected_status)
E               AssertionError: 422 != 400

tests/test_api.py:724: AssertionError
----------------------------- Captured stderr call -----------------------------
{"asctime": "2025-06-06 16:52:04,370", "levelname": "INFO", "request_id": null, "module": "auth", "funcName": "login", "lineno": 98, "message": "User logged in: plinko_validation_user (ID: 1)"}
------------------------------ Captured log call -------------------------------
INFO     casino_be.app:auth.py:98 User logged in: plinko_validation_user (ID: 1)
_____________ TestBaccaratAPI.test_get_baccarat_hand_admin_access ______________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_get_baccarat_hand_admin_access>
mock_hand_query = <MagicMock name='query' id='139776203299648'>

    @patch('casino_be.models.BaccaratHand.query')
    def test_get_baccarat_hand_admin_access(self, mock_hand_query):
        self.mock_user.is_admin = True # Make current_user an admin
        # Hand belongs to another user, but admin should access
        mock_hand = BaccaratHand(id=1, user_id=2, table_id=1, total_bet_amount=100, outcome="player_win")
        mock_hand_query.get.return_value = mock_hand

        response = self.app.get('/api/baccarat/hands/1', headers={'Authorization': 'Bearer testtoken'})
>       self.assertEqual(response.status_code, 200)
E       AssertionError: 422 != 200

tests/test_baccarat_api.py:211: AssertionError
_______________ TestBaccaratAPI.test_get_baccarat_hand_not_found _______________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_get_baccarat_hand_not_found>
mock_hand_query = <MagicMock name='query' id='139776203507456'>

    @patch('casino_be.models.BaccaratHand.query')
    def test_get_baccarat_hand_not_found(self, mock_hand_query):
        mock_hand_query.get.return_value = None
        response = self.app.get('/api/baccarat/hands/999', headers={'Authorization': 'Bearer testtoken'})
>       self.assertEqual(response.status_code, 404)
E       AssertionError: 422 != 404

tests/test_baccarat_api.py:185: AssertionError
________________ TestBaccaratAPI.test_get_baccarat_hand_success ________________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_get_baccarat_hand_success>
mock_hand_query = <MagicMock name='query' id='139776204105632'>

    @patch('casino_be.models.BaccaratHand.query')
    def test_get_baccarat_hand_success(self, mock_hand_query):
        mock_hand = BaccaratHand(id=1, user_id=self.mock_user.id, table_id=1, total_bet_amount=100, outcome="player_win")
        # Simulate filter_by().first()
        mock_hand_query.get.return_value = mock_hand

        response = self.app.get('/api/baccarat/hands/1', headers={'Authorization': 'Bearer testtoken'})
>       self.assertEqual(response.status_code, 200)
E       AssertionError: 422 != 200

tests/test_baccarat_api.py:175: AssertionError
_____________ TestBaccaratAPI.test_get_baccarat_hand_unauthorized ______________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_get_baccarat_hand_unauthorized>
mock_hand_query = <MagicMock name='query' id='139776203707136'>

    @patch('casino_be.models.BaccaratHand.query')
    def test_get_baccarat_hand_unauthorized(self, mock_hand_query):
        # Hand belongs to another user
        mock_hand = BaccaratHand(id=1, user_id=2, table_id=1, total_bet_amount=100, outcome="player_win")
        mock_hand_query.get.return_value = mock_hand

        # current_user.is_admin is False by default in self.mock_user
        response = self.app.get('/api/baccarat/hands/1', headers={'Authorization': 'Bearer testtoken'})
>       self.assertEqual(response.status_code, 403)
E       AssertionError: 422 != 403

tests/test_baccarat_api.py:198: AssertionError
___________________ TestBaccaratAPI.test_get_baccarat_tables ___________________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_get_baccarat_tables>
mock_query = <MagicMock name='query' id='139776204933344'>

    @patch('casino_be.models.BaccaratTable.query')
    def test_get_baccarat_tables(self, mock_query):
        # Mock DB response
        table1 = BaccaratTable(id=1, name="Baccarat Table 1", min_bet=100, max_bet=1000, max_tie_bet=200, commission_rate=Decimal("0.05"), is_active=True)
        table2 = BaccaratTable(id=2, name="Baccarat Table 2", min_bet=500, max_bet=5000, max_tie_bet=1000, commission_rate=Decimal("0.05"), is_active=True)
        mock_query.filter_by.return_value.order_by.return_value.all.return_value = [table1, table2]

        response = self.app.get('/api/baccarat/tables', headers={'Authorization': 'Bearer testtoken'})

>       self.assertEqual(response.status_code, 200)
E       AssertionError: 422 != 200

tests/test_baccarat_api.py:48: AssertionError
_____________ TestBaccaratAPI.test_join_baccarat_table_not_active ______________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_join_baccarat_table_not_active>
mock_query_table = <MagicMock name='query' id='139776203707376'>

    @patch('casino_be.models.BaccaratTable.query')
    def test_join_baccarat_table_not_active(self, mock_query_table):
        mock_table = BaccaratTable(id=1, name="Baccarat Table 1", is_active=False)
        mock_query_table.get.return_value = mock_table
        response = self.app.post('/api/baccarat/tables/1/join', headers={'Authorization': 'Bearer testtoken'})
>       self.assertEqual(response.status_code, 400) # As per current app.py logic
E       AssertionError: 422 != 400

tests/test_baccarat_api.py:80: AssertionError
______________ TestBaccaratAPI.test_join_baccarat_table_not_found ______________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_join_baccarat_table_not_found>
mock_query_table = <MagicMock name='query' id='139776203525088'>

    @patch('casino_be.models.BaccaratTable.query')
    def test_join_baccarat_table_not_found(self, mock_query_table):
        mock_query_table.get.return_value = None
        response = self.app.post('/api/baccarat/tables/99/join', headers={'Authorization': 'Bearer testtoken'})
>       self.assertEqual(response.status_code, 404)
E       AssertionError: 422 != 404

tests/test_baccarat_api.py:70: AssertionError
_______________ TestBaccaratAPI.test_join_baccarat_table_success _______________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_join_baccarat_table_success>
mock_query_table = <MagicMock name='query' id='139776203802080'>

    @patch('casino_be.models.BaccaratTable.query')
    def test_join_baccarat_table_success(self, mock_query_table):
        mock_table = BaccaratTable(id=1, name="Baccarat Table 1", is_active=True)
        mock_query_table.get.return_value = mock_table

        response = self.app.post('/api/baccarat/tables/1/join', headers={'Authorization': 'Bearer testtoken'})
>       self.assertEqual(response.status_code, 200)
E       AssertionError: 422 != 200

tests/test_baccarat_api.py:60: AssertionError
_________ TestBaccaratAPI.test_play_baccarat_hand_insufficient_balance _________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_play_baccarat_hand_insufficient_balance>
mock_play_baccarat = <MagicMock name='play_baccarat_hand' id='139776203522160'>
mock_gs_query = <MagicMock name='query' id='139776203531088'>
mock_bt_query = <MagicMock name='query' id='139776229296736'>
mock_db_flush = <MagicMock name='flush' id='139776202441392'>
mock_db_commit = <MagicMock name='commit' id='139776204147248'>
mock_db_add = <MagicMock name='add' id='139776204151712'>

    @patch('casino_be.app.db.session.add')
    @patch('casino_be.app.db.session.commit')
    @patch('casino_be.app.db.session.flush')
    @patch('casino_be.models.BaccaratTable.query')
    @patch('casino_be.models.GameSession.query')
    @patch('casino_be.utils.baccarat_helper.play_baccarat_hand')
    def test_play_baccarat_hand_insufficient_balance(
        self, mock_play_baccarat, mock_gs_query, mock_bt_query,
        mock_db_flush, mock_db_commit, mock_db_add
    ):
        self.mock_user.balance = 50 # Insufficient for 100 bet
        mock_table = BaccaratTable(
            id=1, name="Test Bacc Table", is_active=True,
            min_bet=10, max_bet=500, max_tie_bet=100,
            commission_rate=Decimal("0.05")
        )
        mock_bt_query.get.return_value = mock_table

        bet_payload = {"table_id": 1, "bet_on_player": 100, "bet_on_banker": 0, "bet_on_tie": 0}
        response = self.app.post('/api/baccarat/hands', json=bet_payload, headers={'Authorization': 'Bearer testtoken'})

>       self.assertEqual(response.status_code, 400)
E       AssertionError: 422 != 400

tests/test_baccarat_api.py:161: AssertionError
__________ TestBaccaratAPI.test_play_baccarat_hand_success_player_win __________

self = <tests.test_baccarat_api.TestBaccaratAPI testMethod=test_play_baccarat_hand_success_player_win>
mock_play_baccarat = <MagicMock name='play_baccarat_hand' id='139776203421248'>
mock_gs_query = <MagicMock name='query' id='139776204938576'>
mock_bt_query = <MagicMock name='query' id='139776203221328'>
mock_db_flush = <MagicMock name='flush' id='139776203213696'>
mock_db_commit = <MagicMock name='commit' id='139776203221088'>
mock_db_add = <MagicMock name='add' id='139776203844448'>

    @patch('casino_be.app.db.session.add')
    @patch('casino_be.app.db.session.commit')
    @patch('casino_be.app.db.session.flush')
    @patch('casino_be.models.BaccaratTable.query')
    @patch('casino_be.models.GameSession.query')
    @patch('casino_be.utils.baccarat_helper.play_baccarat_hand')
    def test_play_baccarat_hand_success_player_win(
        self, mock_play_baccarat, mock_gs_query, mock_bt_query,
        mock_db_flush, mock_db_commit, mock_db_add
    ):
        # Setup mocks
        self.mock_user.balance = 1000 # Sufficient balance
        mock_table = BaccaratTable(
            id=1, name="Test Bacc Table", is_active=True,
            min_bet=10, max_bet=500, max_tie_bet=100,
            commission_rate=Decimal("0.05")
        )
        mock_bt_query.get.return_value = mock_table

        # Mock GameSession query to simulate no existing session or one for a different table
        mock_gs_query.filter_by.return_value.all.return_value = [] # No old sessions to end
        mock_gs_query.filter_by.return_value.first.return_value = None # No existing baccarat session for this table

        mock_helper_result = {
            "player_cards": ["HA", "H8"], "banker_cards": ["C2", "C5"],
            "player_score": 8, "banker_score": 7, "outcome": "player_win",
            "total_winnings": Decimal(200), # Gross: bet 100, win 100 -> total 200
            "net_profit": Decimal(100),
            "commission_paid": Decimal(0),
            "details": {}
        }
        mock_play_baccarat.return_value = mock_helper_result

        bet_payload = {
            "table_id": 1,
            "bet_on_player": 100,
            "bet_on_banker": 0,
            "bet_on_tie": 0
        }
        response = self.app.post('/api/baccarat/hands', json=bet_payload, headers={'Authorization': 'Bearer testtoken'})

>       self.assertEqual(response.status_code, 200, msg=response.get_data(as_text=True))
E       AssertionError: 422 != 200 : {"msg":"Not enough segments"}

tests/test_baccarat_api.py:126: AssertionError
_______ TestBaccaratHelper.test_banker_stands_player_draws_third_card_8 ________

self = <tests.test_baccarat_helper.TestBaccaratHelper testMethod=test_banker_stands_player_draws_third_card_8>
mock_deal_card = <MagicMock name='_deal_card' id='139776226780608'>

    @patch('casino_be.utils.baccarat_helper._deal_card')
    def test_banker_stands_player_draws_third_card_8(self, mock_deal_card):
        # Player: HA, H2 (3) -> Draws H8 (value 8). Player total 1.
        # Banker: H1, H2 (3) -> Player's 3rd card is 8. Banker stands. Banker total 3.
        # Outcome: Banker wins.
        mock_deal_card.side_effect = ["HA", "H1", "H2", "H2", "H8"] # P:HA,H2 (3) dr H8 (1). B:H1,H2 (3) stands.
>       result = baccarat_helper.play_baccarat_hand(Decimal(0), Decimal(10), Decimal(0))

tests/test_baccarat_helper.py:214:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
utils/baccarat_helper.py:148: in play_baccarat_hand
    banker_score = _calculate_baccarat_hand_value(banker_cards)
utils/baccarat_helper.py:55: in _calculate_baccarat_hand_value
    total_value += _get_card_baccarat_value(card)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

card_str = 'H1'

    def _get_card_baccarat_value(card_str):
        """
        Calculates the Baccarat value of a single card.
        'A': 1
        'K', 'Q', 'J', 'T': 0
        '2'-'9': Their integer value.
        """
        rank = card_str[1:]
        if rank == 'A':
            return 1
        elif rank in ['K', 'Q', 'J', 'T']:
            return 0
        elif rank.isdigit():
            value = int(rank)
            if 2 <= value <= 9:
                return value
>       raise ValueError(f"Invalid card rank: {rank} in card {card_str}")
E       ValueError: Invalid card rank: 1 in card H1

utils/baccarat_helper.py:46: ValueError
_______________ TestBaccaratHelper.test_banker_third_card_rules ________________

self = <tests.test_baccarat_helper.TestBaccaratHelper testMethod=test_banker_third_card_rules>
mock_deal_card = <MagicMock name='_deal_card' id='139776203520944'>

    @patch('casino_be.utils.baccarat_helper._deal_card')
    def test_banker_third_card_rules(self, mock_deal_card):
        # Scenario 1: Player stands (score 6 or 7). Banker draws if score 0-5.
        # Player: H6, HK (6) -> Stands.
        # Banker: H2, H3 (5) -> Banker Draws. Banker draws H1 (1). Banker total 6.
        # Outcome: Tie
        mock_deal_card.side_effect = ["H6", "H2", "HK", "H3", "HA"] # P: H6,HK (6) -> stands. B: H2,H3 (5) -> draws HA (6)
        result = baccarat_helper.play_baccarat_hand(Decimal(0), Decimal(0), Decimal(10)) # Bet on Tie
        self.assertEqual(result["outcome"], "tie")
        self.assertEqual(result["player_score"], 6)
        self.assertEqual(result["banker_score"], 6)
        self.assertEqual(len(result["player_cards"]), 2)
        self.assertEqual(len(result["banker_cards"]), 3)
        self.assertFalse(result["details"]["player_drew_third"])
        self.assertTrue(result["details"]["banker_drew_third"])
        self.assertEqual(result["net_profit"], Decimal(80))

        # Scenario 2: Player draws. Banker score 3, Player's 3rd card NOT 8. Banker draws.
        # Player: HA, H2 (3) -> Draws H4 (value 4). Player total 7.
        # Banker: H1, H2 (3) -> Player's 3rd card is 4 (not 8). Banker draws. Banker draws H1 (1). Banker total 4.
        # Outcome: Player wins.
        mock_deal_card.side_effect = ["HA", "H1", "H2", "H2", "H4", "HA"] # P:HA,H2 (3) dr H4 (7). B:H1,H2 (3) dr HA (4)
>       result = baccarat_helper.play_baccarat_hand(Decimal(10), Decimal(0), Decimal(0))

tests/test_baccarat_helper.py:185:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
utils/baccarat_helper.py:148: in play_baccarat_hand
    banker_score = _calculate_baccarat_hand_value(banker_cards)
utils/baccarat_helper.py:55: in _calculate_baccarat_hand_value
    total_value += _get_card_baccarat_value(card)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

card_str = 'H1'

    def _get_card_baccarat_value(card_str):
        """
        Calculates the Baccarat value of a single card.
        'A': 1
        'K', 'Q', 'J', 'T': 0
        '2'-'9': Their integer value.
        """
        rank = card_str[1:]
        if rank == 'A':
            return 1
        elif rank in ['K', 'Q', 'J', 'T']:
            return 0
        elif rank.isdigit():
            value = int(rank)
            if 2 <= value <= 9:
                return value
>       raise ValueError(f"Invalid card rank: {rank} in card {card_str}")
E       ValueError: Invalid card rank: 1 in card H1

utils/baccarat_helper.py:46: ValueError
____________ TestBaccaratHelper.test_play_baccarat_hand_natural_win ____________

self = <tests.test_baccarat_helper.TestBaccaratHelper testMethod=test_play_baccarat_hand_natural_win>
mock_deal_card = <MagicMock name='_deal_card' id='139776257867344'>

    @patch('casino_be.utils.baccarat_helper._deal_card')
    def test_play_baccarat_hand_natural_win(self, mock_deal_card):
        # Player natural 8
        mock_deal_card.side_effect = ["H8", "C2", "SA", "C3"] # P: H8, SA (9); B: C2, C3 (5) -> Error in logic: P: H8, SA (9), B: C2,C3 (5) -> P Nat 8
                                                        # Corrected side effect for Player Natural 8: P: H8, Dk (8); B: C2, C3 (5)
        mock_deal_card.side_effect = ["H8", "C2", "DK", "C3"] # P: H8, DK (8); B: C2, C3 (5)
>       result = baccarat_helper.play_baccarat_hand(Decimal(10), Decimal(0), Decimal(0))

tests/test_baccarat_helper.py:119:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

player_bet_amount = Decimal('10'), banker_bet_amount = Decimal('0')
tie_bet_amount = Decimal('0'), num_decks = 6, commission_rate = Decimal('0.05')
tie_payout_rate = 8

    def play_baccarat_hand(player_bet_amount, banker_bet_amount, tie_bet_amount, num_decks=6, commission_rate=Decimal("0.05"), tie_payout_rate=8):
        """
        Simulates a single hand of Baccarat.
        """
        deck = _create_deck(num_decks)
        _shuffle_deck(deck)

        player_cards = []
        banker_cards = []
        player_third_card = None # Store the value of player's third card if drawn

        # Initial Deal (Player, Banker, Player, Banker)
        try:
            player_cards.append(_deal_card(deck))
            banker_cards.append(_deal_card(deck))
            player_cards.append(_deal_card(deck))
            banker_cards.append(_deal_card(deck))
        except ValueError:
            # Handle empty deck during initial deal - should not happen with standard num_decks
            return {"error": "Deck empty during initial deal. Critical error."}

        player_score = _calculate_baccarat_hand_value(player_cards)
        banker_score = _calculate_baccarat_hand_value(banker_cards)

        outcome = None

        # Natural Win Check
        if player_score >= 8 or banker_score >= 8:
            if player_score == banker_score:
                outcome = "tie"
            elif player_score > banker_score:
                outcome = "player_win"
            else:
                outcome = "banker_win"
        else:
            # Player's Third Card Rule
            player_drew_third = False
            if player_score <= 5:
                try:
                    card = _deal_card(deck)
                    player_cards.append(card)
                    player_third_card_value = _get_card_baccarat_value(card) # Value needed for Banker's rule
                    player_score = _calculate_baccarat_hand_value(player_cards)
                    player_drew_third = True
                except ValueError:
                    # If deck runs out here, hand might end prematurely or be invalid.
                    # For simulation, assume it's unlikely with 6 decks for one hand.
                    # If it does, the current scores would stand.
                    pass


            # Banker's Third Card Rule
            banker_drew_third = False
            if not player_drew_third: # Player stood pat (2 cards)
                if banker_score <= 5:
                    try:
                        banker_cards.append(_deal_card(deck))
                        banker_score = _calculate_baccarat_hand_value(banker_cards)
                        banker_drew_third = True
                    except ValueError:
                        pass # Deck ran out
            else: # Player drew a third card
                if banker_score <= 2:
                    try:
                        banker_cards.append(_deal_card(deck))
                        banker_score = _calculate_baccarat_hand_value(banker_cards)
                        banker_drew_third = True
                    except ValueError:
                        pass
                elif banker_score == 3:
                    if player_third_card_value != 8:
                        try:
                            banker_cards.append(_deal_card(deck))
                            banker_score = _calculate_baccarat_hand_value(banker_cards)
                            banker_drew_third = True
                        except ValueError:
                            pass
                elif banker_score == 4:
                    if player_third_card_value in [2, 3, 4, 5, 6, 7]:
                        try:
                            banker_cards.append(_deal_card(deck))
                            banker_score = _calculate_baccarat_hand_value(banker_cards)
                            banker_drew_third = True
                        except ValueError:
                            pass
                elif banker_score == 5:
                    if player_third_card_value in [4, 5, 6, 7]:
                        try:
                            banker_cards.append(_deal_card(deck))
                            banker_score = _calculate_baccarat_hand_value(banker_cards)
                            banker_drew_third = True
                        except ValueError:
                            pass
                elif banker_score == 6:
                    if player_third_card_value in [6, 7]:
                        try:
                            banker_cards.append(_deal_card(deck))
                            banker_score = _calculate_baccarat_hand_value(banker_cards)
                            banker_drew_third = True
                        except ValueError:
                            pass
                # Banker score 7: Banker stands (already handled as no draw if condition not met)

            # Determine Final Winner (if not determined by natural)
            if player_score == banker_score:
                outcome = "tie"
            elif player_score > banker_score:
                outcome = "player_win"
            else:
                outcome = "banker_win"

        # Calculate Payouts
        # Bets are Decimal, convert if they are not
        dec_player_bet = Decimal(str(player_bet_amount))
        dec_banker_bet = Decimal(str(banker_bet_amount))
        dec_tie_bet = Decimal(str(tie_bet_amount))

        payout_player, payout_banker, payout_tie, commission_paid_val = _calculate_payouts(
            outcome, dec_player_bet, dec_banker_bet, dec_tie_bet,
            commission_rate=Decimal(str(commission_rate)),
            tie_payout_rate=int(tie_payout_rate)
        )

        total_winnings = payout_player + payout_banker + payout_tie
        total_bet = dec_player_bet + dec_banker_bet + dec_tie_bet
        net_profit = total_winnings - total_bet

        return {
            "player_cards": player_cards,
            "banker_cards": banker_cards,
            "player_score": player_score,
            "banker_score": banker_score,
>           "player_third_card_value_if_drawn": player_third_card_value if player_drew_third else None, # For debugging/logging
            "outcome": outcome,
            "total_winnings": total_winnings, # This is the total amount returned to the player (includes original winning bets)
            "net_profit": net_profit, # This is (total_winnings - total_amount_bet)
            "commission_paid": commission_paid_val,
            "details": {
                "player_bet": dec_player_bet,
                "banker_bet": dec_banker_bet,
                "tie_bet": dec_tie_bet,
                "commission_rate": commission_rate,
                "tie_payout_rate": tie_payout_rate,
                "player_drew_third": player_drew_third,
                "banker_drew_third": banker_drew_third # Added for more detailed logging
            }
        }
E       UnboundLocalError: local variable 'player_drew_third' referenced before assignment

utils/baccarat_helper.py:258: UnboundLocalError
_______ TestMultiwaySpinHandler.test_multiway_bonus_end_after_last_spin ________

self = <tests.test_multiway_helper.TestMultiwaySpinHandler testMethod=test_multiway_bonus_end_after_last_spin>

    def setUp(self):
        self.app = app
        # self.app.config.update(TESTING=True) # Ensure testing config if not already set by env vars
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

        self.user = User(username='testmultiwayuser', email='testmw@example.com', password='password')
        self.user.balance = 100000 # Sats
        db.session.add(self.user)

        self.slot = Slot(
            id=2, # Match config
            name="Test Multiway Slot",
            short_name="test_multiway1",
            num_rows=3, # Max rows
            num_columns=5, # Num reels
            num_symbols=11, # Added default based on config
            asset_directory="/test_assets/", # Added missing non-nullable field
            is_active=True,
            rtp=95.0,
            volatility="High",
            is_multiway=True,
            reel_configurations={"possible_counts_per_reel": [[3],[3],[3],[3],[3]]} # Default, can be overridden
        )
        db.session.add(self.slot)
        # Create SlotSymbol instances based on BASE_MULTIWAY_GAME_CONFIG
        for symbol_data in BASE_MULTIWAY_GAME_CONFIG['game']['symbols']:
>           slot_symbol = SlotSymbol(
                slot_id=self.slot.id,
                symbol_internal_id=symbol_data['id'],
                name=symbol_data['name'],
                img_link=symbol_data['asset'], # Assuming 'asset' is the img_link
                value_multiplier=0.0, # Default, as payouts are in ways_payouts/scatter_payouts
                data=symbol_data # Store whole symbol config in data if needed
            )
E           NameError: name 'SlotSymbol' is not defined

tests/test_multiway_helper.py:76: NameError
____ TestMultiwaySpinHandler.test_multiway_bonus_spin_behavior_win_and_cost ____

self = <tests.test_multiway_helper.TestMultiwaySpinHandler testMethod=test_multiway_bonus_spin_behavior_win_and_cost>

    def setUp(self):
        self.app = app
        # self.app.config.update(TESTING=True) # Ensure testing config if not already set by env vars
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

        self.user = User(username='testmultiwayuser', email='testmw@example.com', password='password')
        self.user.balance = 100000 # Sats
        db.session.add(self.user)

        self.slot = Slot(
            id=2, # Match config
            name="Test Multiway Slot",
            short_name="test_multiway1",
            num_rows=3, # Max rows
            num_columns=5, # Num reels
            num_symbols=11, # Added default based on config
            asset_directory="/test_assets/", # Added missing non-nullable field
            is_active=True,
            rtp=95.0,
            volatility="High",
            is_multiway=True,
            reel_configurations={"possible_counts_per_reel": [[3],[3],[3],[3],[3]]} # Default, can be overridden
        )
        db.session.add(self.slot)
        # Create SlotSymbol instances based on BASE_MULTIWAY_GAME_CONFIG
        for symbol_data in BASE_MULTIWAY_GAME_CONFIG['game']['symbols']:
>           slot_symbol = SlotSymbol(
                slot_id=self.slot.id,
                symbol_internal_id=symbol_data['id'],
                name=symbol_data['name'],
                img_link=symbol_data['asset'], # Assuming 'asset' is the img_link
                value_multiplier=0.0, # Default, as payouts are in ways_payouts/scatter_payouts
                data=symbol_data # Store whole symbol config in data if needed
            )
E           NameError: name 'SlotSymbol' is not defined

tests/test_multiway_helper.py:76: NameError
__________ TestMultiwaySpinHandler.test_multiway_free_spin_retrigger ___________

self = <tests.test_multiway_helper.TestMultiwaySpinHandler testMethod=test_multiway_free_spin_retrigger>

    def setUp(self):
        self.app = app
        # self.app.config.update(TESTING=True) # Ensure testing config if not already set by env vars
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

        self.user = User(username='testmultiwayuser', email='testmw@example.com', password='password')
        self.user.balance = 100000 # Sats
        db.session.add(self.user)

        self.slot = Slot(
            id=2, # Match config
            name="Test Multiway Slot",
            short_name="test_multiway1",
            num_rows=3, # Max rows
            num_columns=5, # Num reels
            num_symbols=11, # Added default based on config
            asset_directory="/test_assets/", # Added missing non-nullable field
            is_active=True,
            rtp=95.0,
            volatility="High",
            is_multiway=True,
            reel_configurations={"possible_counts_per_reel": [[3],[3],[3],[3],[3]]} # Default, can be overridden
        )
        db.session.add(self.slot)
        # Create SlotSymbol instances based on BASE_MULTIWAY_GAME_CONFIG
        for symbol_data in BASE_MULTIWAY_GAME_CONFIG['game']['symbols']:
>           slot_symbol = SlotSymbol(
                slot_id=self.slot.id,
                symbol_internal_id=symbol_data['id'],
                name=symbol_data['name'],
                img_link=symbol_data['asset'], # Assuming 'asset' is the img_link
                value_multiplier=0.0, # Default, as payouts are in ways_payouts/scatter_payouts
                data=symbol_data # Store whole symbol config in data if needed
            )
E           NameError: name 'SlotSymbol' is not defined

tests/test_multiway_helper.py:76: NameError
___________ TestMultiwaySpinHandler.test_multiway_free_spin_trigger ____________

self = <tests.test_multiway_helper.TestMultiwaySpinHandler testMethod=test_multiway_free_spin_trigger>

    def setUp(self):
        self.app = app
        # self.app.config.update(TESTING=True) # Ensure testing config if not already set by env vars
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

        self.user = User(username='testmultiwayuser', email='testmw@example.com', password='password')
        self.user.balance = 100000 # Sats
        db.session.add(self.user)

        self.slot = Slot(
            id=2, # Match config
            name="Test Multiway Slot",
            short_name="test_multiway1",
            num_rows=3, # Max rows
            num_columns=5, # Num reels
            num_symbols=11, # Added default based on config
            asset_directory="/test_assets/", # Added missing non-nullable field
            is_active=True,
            rtp=95.0,
            volatility="High",
            is_multiway=True,
            reel_configurations={"possible_counts_per_reel": [[3],[3],[3],[3],[3]]} # Default, can be overridden
        )
        db.session.add(self.slot)
        # Create SlotSymbol instances based on BASE_MULTIWAY_GAME_CONFIG
        for symbol_data in BASE_MULTIWAY_GAME_CONFIG['game']['symbols']:
>           slot_symbol = SlotSymbol(
                slot_id=self.slot.id,
                symbol_internal_id=symbol_data['id'],
                name=symbol_data['name'],
                img_link=symbol_data['asset'], # Assuming 'asset' is the img_link
                value_multiplier=0.0, # Default, as payouts are in ways_payouts/scatter_payouts
                data=symbol_data # Store whole symbol config in data if needed
            )
E           NameError: name 'SlotSymbol' is not defined

tests/test_multiway_helper.py:76: NameError
___________________ TestHandleFold.test_handle_fold_success ____________________

self = <tests.test_poker_actions.TestHandleFold testMethod=test_handle_fold_success>
mock_check_betting_completion = <MagicMock name='_check_betting_round_completion' id='139776203007040'>

    @patch('casino_be.utils.poker_helper._check_betting_round_completion')
    def test_handle_fold_success(self, mock_check_betting_completion):
        # Setup mocks for this specific test
        self.mock_db_session.query(PokerPlayerState).filter_by(user_id=self.user_id, table_id=self.table_id).first.return_value = self.mock_player_state
>       self.mock_db_session.query(PokerHand).get(self.hand_id).first.return_value = self.mock_poker_hand # Corrected from .get(id) to .get(hand_id)
E       AttributeError: 'NoneType' object has no attribute 'first'

tests/test_poker_actions.py:66: AttributeError
_____________________ TestHandleBet.test_handle_bet_all_in _____________________

self = <tests.test_poker_actions.TestHandleBet testMethod=test_handle_bet_all_in>
MockTransaction = <MagicMock name='Transaction' id='139776201191488'>
mock_validate_bet = <MagicMock name='_validate_bet' id='139776203142864'>
mock_check_betting_completion = <MagicMock name='_check_betting_round_completion' id='139776201101648'>

    @patch('casino_be.utils.poker_helper._check_betting_round_completion')
    @patch('casino_be.utils.poker_helper._validate_bet')
    @patch('casino_be.utils.poker_helper.Transaction')
    def test_handle_bet_all_in(self, MockTransaction, mock_validate_bet, mock_check_betting_completion):
        bet_amount = 10000 # Player intends to bet their whole stack
        self.mock_player_state.stack_sats = 10000
        mock_validate_bet.return_value = (True, "Valid No-Limit all-in opening bet.")
        mock_check_betting_completion.return_value = {"status": "all_in_showdown"}

>       result = handle_bet(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=bet_amount)

tests/test_poker_actions.py:487:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 10000

    def handle_bet(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's bet action."""
        """
        Handles a player's bet action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns an error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns an error.
        - Initializes poker_hand.player_street_investments to {} if None.
        - Calculates player_invested_this_street and current_bet_to_match_val.
        - If current_bet_to_match_val > player_invested_this_street, returns error "Cannot bet, must call or raise...".
        - Validates min_bet_val.
        - Calculates actual_bet_amount_put_in_pot and is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, current_bet_to_match, last_raiser_user_id, min_next_raise_amount).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0:
            return {"error": "Bet amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive bet for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:827: AttributeError
______________ TestHandleBet.test_handle_bet_fail_outstanding_bet ______________

self = <tests.test_poker_actions.TestHandleBet testMethod=test_handle_bet_fail_outstanding_bet>

    def test_handle_bet_fail_outstanding_bet(self):
        self.mock_poker_hand.current_bet_to_match = 100 # There is an outstanding bet
        self.mock_poker_hand.player_street_investments = {str(self.user_id): 0} # Player hasn't called it

>       result = handle_bet(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=50)

tests/test_poker_actions.py:472:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 50

    def handle_bet(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's bet action."""
        """
        Handles a player's bet action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns an error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns an error.
        - Initializes poker_hand.player_street_investments to {} if None.
        - Calculates player_invested_this_street and current_bet_to_match_val.
        - If current_bet_to_match_val > player_invested_this_street, returns error "Cannot bet, must call or raise...".
        - Validates min_bet_val.
        - Calculates actual_bet_amount_put_in_pot and is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, current_bet_to_match, last_raiser_user_id, min_next_raise_amount).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0:
            return {"error": "Bet amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive bet for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:827: AttributeError
________________ TestHandleBet.test_handle_bet_fail_validation _________________

self = <tests.test_poker_actions.TestHandleBet testMethod=test_handle_bet_fail_validation>
mock_validate_bet = <MagicMock name='_validate_bet' id='139776202807312'>

    @patch('casino_be.utils.poker_helper._validate_bet')
    def test_handle_bet_fail_validation(self, mock_validate_bet):
        bet_amount = 10 # Too small
        mock_validate_bet.return_value = (False, "Bet amount too small.")

>       result = handle_bet(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=bet_amount)

tests/test_poker_actions.py:462:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 10

    def handle_bet(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's bet action."""
        """
        Handles a player's bet action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns an error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns an error.
        - Initializes poker_hand.player_street_investments to {} if None.
        - Calculates player_invested_this_street and current_bet_to_match_val.
        - If current_bet_to_match_val > player_invested_this_street, returns error "Cannot bet, must call or raise...".
        - Validates min_bet_val.
        - Calculates actual_bet_amount_put_in_pot and is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, current_bet_to_match, last_raiser_user_id, min_next_raise_amount).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0:
            return {"error": "Bet amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive bet for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:827: AttributeError
____________________ TestHandleBet.test_handle_bet_success _____________________

self = <tests.test_poker_actions.TestHandleBet testMethod=test_handle_bet_success>
MockTransaction = <MagicMock name='Transaction' id='139776202564816'>
mock_validate_bet = <MagicMock name='_validate_bet' id='139776202678544'>
mock_check_betting_completion = <MagicMock name='_check_betting_round_completion' id='139776202681952'>

    @patch('casino_be.utils.poker_helper._check_betting_round_completion')
    @patch('casino_be.utils.poker_helper._validate_bet') # Mock _validate_bet
    @patch('casino_be.utils.poker_helper.Transaction')
    def test_handle_bet_success(self, MockTransaction, mock_validate_bet, mock_check_betting_completion):
        bet_amount = 100
        mock_validate_bet.return_value = (True, "Valid No-Limit opening bet.")
        mock_check_betting_completion.return_value = {"status": "betting_continues", "next_to_act_user_id": 2}

        initial_stack = self.mock_player_state.stack_sats
        initial_pot_size = self.mock_poker_hand.pot_size_sats
        player_initial_street_investment = self.mock_poker_hand.player_street_investments.get(str(self.user_id), 0)


>       result = handle_bet(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=bet_amount)

tests/test_poker_actions.py:427:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 100

    def handle_bet(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's bet action."""
        """
        Handles a player's bet action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns an error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns an error.
        - Initializes poker_hand.player_street_investments to {} if None.
        - Calculates player_invested_this_street and current_bet_to_match_val.
        - If current_bet_to_match_val > player_invested_this_street, returns error "Cannot bet, must call or raise...".
        - Validates min_bet_val.
        - Calculates actual_bet_amount_put_in_pot and is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, current_bet_to_match, last_raiser_user_id, min_next_raise_amount).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0:
            return {"error": "Bet amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive bet for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:827: AttributeError
__________ TestHandleRaise.test_handle_raise_all_in_incomplete_raise ___________

self = <tests.test_poker_actions.TestHandleRaise testMethod=test_handle_raise_all_in_incomplete_raise>
MockTransaction = <MagicMock name='Transaction' id='139776203511872'>
mock_validate_bet = <MagicMock name='_validate_bet' id='139776202701072'>
mock_check_betting_completion = <MagicMock name='_check_betting_round_completion' id='139776202694208'>

    @patch('casino_be.utils.poker_helper._check_betting_round_completion')
    @patch('casino_be.utils.poker_helper._validate_bet')
    @patch('casino_be.utils.poker_helper.Transaction')
    def test_handle_raise_all_in_incomplete_raise(self, MockTransaction, mock_validate_bet, mock_check_betting_completion):
        # Current bet 100, player has 50 invested. Player stack is 70.
        # Player wants to raise TO 120 (50 call + 20 raise), which is their all-in.
        # Min raise would be to 200. This is an incomplete all-in raise.
        self.mock_player_state.stack_sats = 70
        self.mock_player_state.total_invested_this_hand = 50
        self.mock_poker_hand.player_street_investments = {str(self.user_id): 50}
        self.mock_poker_hand.current_bet_to_match = 100

        raise_to_amount_total = 120 # Player goes all-in for 70 more, total investment 120
        actual_added_to_pot = 70

        mock_validate_bet.return_value = (True, "Valid No-Limit all-in raise.") # _validate_bet should confirm this is valid all-in
        mock_check_betting_completion.return_value = {"status": "all_in_showdown"}

>       result = handle_raise(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=raise_to_amount_total)

tests/test_poker_actions.py:618:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 120

    def handle_raise(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's raise action."""
        """
        Handles a player's raise action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns error.
        - Initializes poker_hand.player_street_investments.
        - Validates raise conditions (prior bet, amount > current bet, min raise increment).
        - Calculates amounts, is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, min_next_raise_amount, current_bet_to_match, last_raiser_user_id).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0: # Amount is the total sum the player is raising TO for the street
            return {"error": "Raise amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive raise for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:983: AttributeError
_____________ TestHandleRaise.test_handle_raise_fail_no_prior_bet ______________

self = <tests.test_poker_actions.TestHandleRaise testMethod=test_handle_raise_fail_no_prior_bet>

    def test_handle_raise_fail_no_prior_bet(self):
        self.mock_poker_hand.current_bet_to_match = 0 # No prior bet

>       result = handle_raise(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=100)

tests/test_poker_actions.py:594:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 100

    def handle_raise(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's raise action."""
        """
        Handles a player's raise action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns error.
        - Initializes poker_hand.player_street_investments.
        - Validates raise conditions (prior bet, amount > current bet, min raise increment).
        - Calculates amounts, is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, min_next_raise_amount, current_bet_to_match, last_raiser_user_id).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0: # Amount is the total sum the player is raising TO for the street
            return {"error": "Raise amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive raise for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:983: AttributeError
______________ TestHandleRaise.test_handle_raise_fail_validation _______________

self = <tests.test_poker_actions.TestHandleRaise testMethod=test_handle_raise_fail_validation>
mock_validate_bet = <MagicMock name='_validate_bet' id='139776204109712'>

    @patch('casino_be.utils.poker_helper._validate_bet')
    def test_handle_raise_fail_validation(self, mock_validate_bet):
        raise_to_amount = 150 # Too small (less than current bet + min increment)
        mock_validate_bet.return_value = (False, "Raise amount too small.")

>       result = handle_raise(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=raise_to_amount)

tests/test_poker_actions.py:585:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 150

    def handle_raise(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's raise action."""
        """
        Handles a player's raise action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns error.
        - Initializes poker_hand.player_street_investments.
        - Validates raise conditions (prior bet, amount > current bet, min raise increment).
        - Calculates amounts, is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, min_next_raise_amount, current_bet_to_match, last_raiser_user_id).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0: # Amount is the total sum the player is raising TO for the street
            return {"error": "Raise amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive raise for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:983: AttributeError
__________________ TestHandleRaise.test_handle_raise_success ___________________

self = <tests.test_poker_actions.TestHandleRaise testMethod=test_handle_raise_success>
MockTransaction = <MagicMock name='Transaction' id='139776202679840'>
mock_validate_bet = <MagicMock name='_validate_bet' id='139776203032512'>
mock_check_betting_completion = <MagicMock name='_check_betting_round_completion' id='139776203038800'>

    @patch('casino_be.utils.poker_helper._check_betting_round_completion')
    @patch('casino_be.utils.poker_helper._validate_bet') # Mock _validate_bet
    @patch('casino_be.utils.poker_helper.Transaction')
    def test_handle_raise_success(self, MockTransaction, mock_validate_bet, mock_check_betting_completion):
        # Player has 50 in, current bet is 100. Min increment is 100. So min raise TO is 100 (call) + 100 (raise) = 200.
        # Player wants to raise TO 250. Needs to add 200 more chips.
        raise_to_amount_total = 250

        mock_validate_bet.return_value = (True, "Valid No-Limit raise.")
        mock_check_betting_completion.return_value = {"status": "betting_continues", "next_to_act_user_id": 2}

        initial_stack = self.mock_player_state.stack_sats # 10000
        initial_pot_size = self.mock_poker_hand.pot_size_sats # 200
        player_initial_street_investment = self.mock_poker_hand.player_street_investments[str(self.user_id)] # 50
        previous_bet_to_match = self.mock_poker_hand.current_bet_to_match # 100

        amount_player_needs_to_add = raise_to_amount_total - player_initial_street_investment # 250 - 50 = 200

>       result = handle_raise(user_id=self.user_id, table_id=self.table_id, hand_id=self.hand_id, amount=raise_to_amount_total)

tests/test_poker_actions.py:552:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_id = 1, table_id = 101, hand_id = 201, amount = 250

    def handle_raise(user_id: int, table_id: int, hand_id: int, amount: int):
        """Placeholder for handling a player's raise action."""
        """
        Handles a player's raise action.
        - Fetches PokerPlayerState, PokerHand, PokerTable.
        - If any not found, or amount <= 0, returns error.
        - Clears player_state.time_to_act_ends.
        - If player not active, returns error.
        - Initializes poker_hand.player_street_investments.
        - Validates raise conditions (prior bet, amount > current bet, min raise increment).
        - Calculates amounts, is_all_in.
        - Updates player_state (stack_sats, total_invested_this_hand).
        - Updates poker_hand (player_street_investments, pot_size_sats, min_next_raise_amount, current_bet_to_match, last_raiser_user_id).
        - Sets action_string and player_state.last_action.
        - Creates Transaction.
        - Initializes and appends to poker_hand.hand_history.
        - Adds all modified objects to session.
        - Calls _check_betting_round_completion and commits.
        - Returns success message or error.
        """
        session = db.session
        player_state = session.query(PokerPlayerState).filter_by(user_id=user_id, table_id=table_id).first()
        poker_hand = session.query(PokerHand).get(hand_id)
        poker_table = session.query(PokerTable).get(table_id)

        if not player_state:
            return {"error": f"Player state for user {user_id} not found at table {table_id}."}
        if not poker_hand:
            return {"error": f"Poker hand {hand_id} not found."}
        if not poker_table:
            return {"error": f"Poker table {table_id} not found."}
        if amount <= 0: # Amount is the total sum the player is raising TO for the street
            return {"error": "Raise amount must be positive."}

        player_state.time_to_act_ends = None

        if not player_state.is_active_in_hand:
            session.add(player_state) # Save cleared timer
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing player_state on inactive raise for user {user_id}: {e}")
            return {"error": f"Player {user_id} is not active in hand {hand_id}."}

>       if poker_hand.player_street_investments is None:
E       AttributeError: 'PokerTable' object has no attribute 'player_street_investments'

utils/poker_helper.py:983: AttributeError
_______________ TestDistributePot.test_one_main_pot_one_side_pot _______________

self = <tests.test_poker_pot_distribution.TestDistributePot testMethod=test_one_main_pot_one_side_pot>
MockTransaction = <MagicMock name='Transaction' id='139776201547376'>
mock_determine_winning_hand = <MagicMock name='_determine_winning_hand' id='139776201555344'>

    @patch('casino_be.utils.poker_helper._determine_winning_hand')
    @patch('casino_be.utils.poker_helper.Transaction')
    def test_one_main_pot_one_side_pot(self, MockTransaction, mock_determine_winning_hand):
        self.mock_poker_table.rake_percentage = Decimal("0.10") # 10% rake
        self.mock_poker_table.max_rake_sats = 10 # Max rake 10

        # P1 all-in for 100. P2 calls 100 and has more. P3 calls 100 and has more.
        # Total pot = 300. Rake = 10. Distributable = 290.
        # Main pot for P1, P2, P3: P1 puts in 100. P2 matches 100. P3 matches 100. Total 300.
        # This setup is for _distribute_pot. Assume pot_size_sats is already calculated.
        # Let's say:
        # P1 invested 100 (all-in)
        # P2 invested 200
        # P3 invested 200
        # Total pot_size_sats on PokerHand = 100 + 200 + 200 = 500
        # Rake = 10. Distributable = 490.

        player1 = self._setup_player(user_id=1, username="P1_AllIn", stack=0, total_invested=100, hole_cards=["AS", "KS"]) # All-in
        player2 = self._setup_player(user_id=2, username="P2_Cover", stack=1000, total_invested=200, hole_cards=["QS", "JS"])
        player3 = self._setup_player(user_id=3, username="P3_Cover", stack=1000, total_invested=200, hole_cards=["TS", "9S"])
        showdown_players = [player1, player2, player3]

        poker_hand = PokerHand(id=self.hand_id, table_id=self.table_id, pot_size_sats=500, board_cards=["2H", "3H", "4H", "5D", "7D"], winners=[])
        self.mock_db_session.query(User).get.side_effect = self.mock_query_user_get

        # P1 wins main pot. P2 wins side pot against P3.
        def side_effect_determine_winner(*args, **kwargs):
            player_map = args[0]
            if 1 in player_map and 2 in player_map and 3 in player_map: # Main pot
                return [{"user_id": 1, "winning_hand": "Flush", "best_five_cards": []}]
            elif 2 in player_map and 3 in player_map: # Side pot P2 vs P3
                return [{"user_id": 2, "winning_hand": "Pair of 7s", "best_five_cards": []}]
            return []
        mock_determine_winning_hand.side_effect = side_effect_determine_winner

>       _distribute_pot(poker_hand, showdown_players)

tests/test_poker_pot_distribution.py:172:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

poker_hand = <PokerHand 1 (Table: 1, Pot: 500, Start: None)>
showdown_player_states = [<PokerPlayerState None (User: 1, Table: 1, Seat: None, Stack: 0)>, <PokerPlayerState None (User: 2, Table: 1, Seat: None, Stack: 1000)>, <PokerPlayerState None (User: 3, Table: 1, Seat: None, Stack: 1000)>]

    def _distribute_pot(poker_hand: PokerHand, showdown_player_states: list[PokerPlayerState]):
        """
        Distributes the pot(s) to the winner(s), handling side pots.
        Updates PokerHand with rake and winner details.
        Creates Transaction records for winnings.
        """
        session = db.session
        poker_table = session.query(PokerTable).get(poker_hand.table_id)

        if not poker_table:
            current_app.logger.error(f"PokerTable {poker_hand.table_id} not found for pot distribution of hand {poker_hand.id}.")
            # This is a critical error, likely indicates data integrity issue or programming error.
            # Depending on desired robustness, could try to proceed without rake or raise exception.
            # For now, let's assume this is fatal for pot distribution.
            return {"error": f"Table not found for pot distribution, hand {poker_hand.id}"}

        # --- 1. Prepare Player Data for Showdown ---
        players_data_for_pots = []
        for ps in showdown_player_states:
            if not ps.hole_cards or len(ps.hole_cards) != 2:
                # Log this, but might not be critical to stop if other players are valid.
                # However, a player at showdown should always have hole cards.
                current_app.logger.warning(f"Player {ps.user_id} at showdown for hand {poker_hand.id} has invalid hole cards: {ps.hole_cards}. Skipping for pot eligibility.")
                continue

            # total_invested_this_hand should be accurately tracked by action handlers.
            # Fallback or error if not present could be added, but spec assumes it's populated.
            total_invested = ps.total_invested_this_hand if ps.total_invested_this_hand is not None else 0

            players_data_for_pots.append({
                'user_id': ps.user_id,
                'total_invested': total_invested,
                'hole_cards_str': ps.hole_cards, # String representation like ["HA", "SK"]
                'player_state_obj': ps # Direct reference to the SQLAlchemy object for stack updates
            })

        if not players_data_for_pots:
            if poker_hand.pot_size_sats > 0:
                # This case means the pot has money, but no valid showdown players were passed.
                # This might happen if only one player remained due to folds (handled before calling _distribute_pot)
                # or an error in game flow logic.
                current_app.logger.warning(f"_distribute_pot called for hand {poker_hand.id} with pot {poker_hand.pot_size_sats} but no valid showdown players. Pot remains unawarded by this function.")
                # Consider refunding pot or specific error handling based on game rules.
            # If pot is 0 and no players, it's fine.
            poker_hand.status = 'completed' # Ensure hand is marked completed
            poker_hand.end_time = datetime.now(timezone.utc)
            session.add(poker_hand)
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing hand completion with no showdown players for hand {poker_hand.id}: {e}")
            return # Or return a status indicating no distribution needed/possible.

        # --- 2. Rake Calculation ---
        total_pot_value_before_rake = poker_hand.pot_size_sats or 0
        actual_rake = 0

        # Apply rake only if conditions are met (e.g., flop seen, or always if pot > 0 as per simplified rule)
        # For now, applying if pot > 0 based on table settings.
        # A more advanced rule: if poker_hand.status not in ['preflop', 'completed'] or len(poker_hand.board_cards) > 0
        if total_pot_value_before_rake > 0:
>           rake_percentage = poker_table.rake_percentage if poker_table.rake_percentage is not None else Decimal("0.00")
E           AttributeError: 'User' object has no attribute 'rake_percentage'

utils/poker_helper.py:1540: AttributeError
________ TestDistributePot.test_single_winner_main_pot_no_rake_cap_hit _________

self = <tests.test_poker_pot_distribution.TestDistributePot testMethod=test_single_winner_main_pot_no_rake_cap_hit>
MockTransaction = <MagicMock name='Transaction' id='139776201508896'>
mock_determine_winning_hand = <MagicMock name='_determine_winning_hand' id='139776201516864'>

    @patch('casino_be.utils.poker_helper._determine_winning_hand')
    @patch('casino_be.utils.poker_helper.Transaction')
    def test_single_winner_main_pot_no_rake_cap_hit(self, MockTransaction, mock_determine_winning_hand):
        self.mock_poker_table.rake_percentage = Decimal("0.10") # 10%
        self.mock_poker_table.max_rake_sats = 500

        player1 = self._setup_player(user_id=1, username="Alice", stack=1000, total_invested=200, hole_cards=["AH", "KH"])
        player2 = self._setup_player(user_id=2, username="Bob", stack=1000, total_invested=200, hole_cards=["QC", "JC"])

        showdown_players = [player1, player2]
        poker_hand = PokerHand(
            id=self.hand_id, table_id=self.table_id, pot_size_sats=400, board_cards=["2D", "3D", "4D", "5S", "6S"],
            player_street_investments={}, winners=[] # Ensure winners is empty list initially
        )

        # Mocking User query within _distribute_pot if winner_user_obj is fetched again.
        # It's better if player_state_obj.user is already loaded.
        self.mock_db_session.query(User).get.side_effect = self.mock_query_user_get

        # Player1 wins the only pot
        mock_determine_winning_hand.return_value = [
            {"user_id": 1, "winning_hand": "Straight", "best_five_cards": ["AH", "KH", "2D", "3D", "4D"]}
        ]

>       _distribute_pot(poker_hand, showdown_players)

tests/test_poker_pot_distribution.py:84:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

poker_hand = <PokerHand 1 (Table: 1, Pot: 400, Start: None)>
showdown_player_states = [<PokerPlayerState None (User: 1, Table: 1, Seat: None, Stack: 1000)>, <PokerPlayerState None (User: 2, Table: 1, Seat: None, Stack: 1000)>]

    def _distribute_pot(poker_hand: PokerHand, showdown_player_states: list[PokerPlayerState]):
        """
        Distributes the pot(s) to the winner(s), handling side pots.
        Updates PokerHand with rake and winner details.
        Creates Transaction records for winnings.
        """
        session = db.session
        poker_table = session.query(PokerTable).get(poker_hand.table_id)

        if not poker_table:
            current_app.logger.error(f"PokerTable {poker_hand.table_id} not found for pot distribution of hand {poker_hand.id}.")
            # This is a critical error, likely indicates data integrity issue or programming error.
            # Depending on desired robustness, could try to proceed without rake or raise exception.
            # For now, let's assume this is fatal for pot distribution.
            return {"error": f"Table not found for pot distribution, hand {poker_hand.id}"}

        # --- 1. Prepare Player Data for Showdown ---
        players_data_for_pots = []
        for ps in showdown_player_states:
            if not ps.hole_cards or len(ps.hole_cards) != 2:
                # Log this, but might not be critical to stop if other players are valid.
                # However, a player at showdown should always have hole cards.
                current_app.logger.warning(f"Player {ps.user_id} at showdown for hand {poker_hand.id} has invalid hole cards: {ps.hole_cards}. Skipping for pot eligibility.")
                continue

            # total_invested_this_hand should be accurately tracked by action handlers.
            # Fallback or error if not present could be added, but spec assumes it's populated.
            total_invested = ps.total_invested_this_hand if ps.total_invested_this_hand is not None else 0

            players_data_for_pots.append({
                'user_id': ps.user_id,
                'total_invested': total_invested,
                'hole_cards_str': ps.hole_cards, # String representation like ["HA", "SK"]
                'player_state_obj': ps # Direct reference to the SQLAlchemy object for stack updates
            })

        if not players_data_for_pots:
            if poker_hand.pot_size_sats > 0:
                # This case means the pot has money, but no valid showdown players were passed.
                # This might happen if only one player remained due to folds (handled before calling _distribute_pot)
                # or an error in game flow logic.
                current_app.logger.warning(f"_distribute_pot called for hand {poker_hand.id} with pot {poker_hand.pot_size_sats} but no valid showdown players. Pot remains unawarded by this function.")
                # Consider refunding pot or specific error handling based on game rules.
            # If pot is 0 and no players, it's fine.
            poker_hand.status = 'completed' # Ensure hand is marked completed
            poker_hand.end_time = datetime.now(timezone.utc)
            session.add(poker_hand)
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing hand completion with no showdown players for hand {poker_hand.id}: {e}")
            return # Or return a status indicating no distribution needed/possible.

        # --- 2. Rake Calculation ---
        total_pot_value_before_rake = poker_hand.pot_size_sats or 0
        actual_rake = 0

        # Apply rake only if conditions are met (e.g., flop seen, or always if pot > 0 as per simplified rule)
        # For now, applying if pot > 0 based on table settings.
        # A more advanced rule: if poker_hand.status not in ['preflop', 'completed'] or len(poker_hand.board_cards) > 0
        if total_pot_value_before_rake > 0:
>           rake_percentage = poker_table.rake_percentage if poker_table.rake_percentage is not None else Decimal("0.00")
E           AttributeError: 'User' object has no attribute 'rake_percentage'

utils/poker_helper.py:1540: AttributeError
____________ TestDistributePot.test_split_pot_two_winners_main_pot _____________

self = <tests.test_poker_pot_distribution.TestDistributePot testMethod=test_split_pot_two_winners_main_pot>
MockTransaction = <MagicMock name='Transaction' id='139776201486112'>
mock_determine_winning_hand = <MagicMock name='_determine_winning_hand' id='139776201444992'>

    @patch('casino_be.utils.poker_helper._determine_winning_hand')
    @patch('casino_be.utils.poker_helper.Transaction')
    def test_split_pot_two_winners_main_pot(self, MockTransaction, mock_determine_winning_hand):
        self.mock_poker_table.rake_percentage = Decimal("0.00") # No rake for simplicity

        player1 = self._setup_player(user_id=1, username="Alice", stack=1000, total_invested=200, hole_cards=["AH", "KH"])
        player2 = self._setup_player(user_id=2, username="Bob", stack=1000, total_invested=200, hole_cards=["AD", "KD"])
        showdown_players = [player1, player2]
        poker_hand = PokerHand(id=self.hand_id, table_id=self.table_id, pot_size_sats=400, board_cards=["2S", "3H", "4C", "5S", "6D"], winners=[])

        self.mock_db_session.query(User).get.side_effect = self.mock_query_user_get

        mock_determine_winning_hand.return_value = [
            {"user_id": 1, "winning_hand": "Straight", "best_five_cards": []},
            {"user_id": 2, "winning_hand": "Straight", "best_five_cards": []}
        ] # Split pot

>       _distribute_pot(poker_hand, showdown_players)

tests/test_poker_pot_distribution.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

poker_hand = <PokerHand 1 (Table: 1, Pot: 400, Start: None)>
showdown_player_states = [<PokerPlayerState None (User: 1, Table: 1, Seat: None, Stack: 1000)>, <PokerPlayerState None (User: 2, Table: 1, Seat: None, Stack: 1000)>]

    def _distribute_pot(poker_hand: PokerHand, showdown_player_states: list[PokerPlayerState]):
        """
        Distributes the pot(s) to the winner(s), handling side pots.
        Updates PokerHand with rake and winner details.
        Creates Transaction records for winnings.
        """
        session = db.session
        poker_table = session.query(PokerTable).get(poker_hand.table_id)

        if not poker_table:
            current_app.logger.error(f"PokerTable {poker_hand.table_id} not found for pot distribution of hand {poker_hand.id}.")
            # This is a critical error, likely indicates data integrity issue or programming error.
            # Depending on desired robustness, could try to proceed without rake or raise exception.
            # For now, let's assume this is fatal for pot distribution.
            return {"error": f"Table not found for pot distribution, hand {poker_hand.id}"}

        # --- 1. Prepare Player Data for Showdown ---
        players_data_for_pots = []
        for ps in showdown_player_states:
            if not ps.hole_cards or len(ps.hole_cards) != 2:
                # Log this, but might not be critical to stop if other players are valid.
                # However, a player at showdown should always have hole cards.
                current_app.logger.warning(f"Player {ps.user_id} at showdown for hand {poker_hand.id} has invalid hole cards: {ps.hole_cards}. Skipping for pot eligibility.")
                continue

            # total_invested_this_hand should be accurately tracked by action handlers.
            # Fallback or error if not present could be added, but spec assumes it's populated.
            total_invested = ps.total_invested_this_hand if ps.total_invested_this_hand is not None else 0

            players_data_for_pots.append({
                'user_id': ps.user_id,
                'total_invested': total_invested,
                'hole_cards_str': ps.hole_cards, # String representation like ["HA", "SK"]
                'player_state_obj': ps # Direct reference to the SQLAlchemy object for stack updates
            })

        if not players_data_for_pots:
            if poker_hand.pot_size_sats > 0:
                # This case means the pot has money, but no valid showdown players were passed.
                # This might happen if only one player remained due to folds (handled before calling _distribute_pot)
                # or an error in game flow logic.
                current_app.logger.warning(f"_distribute_pot called for hand {poker_hand.id} with pot {poker_hand.pot_size_sats} but no valid showdown players. Pot remains unawarded by this function.")
                # Consider refunding pot or specific error handling based on game rules.
            # If pot is 0 and no players, it's fine.
            poker_hand.status = 'completed' # Ensure hand is marked completed
            poker_hand.end_time = datetime.now(timezone.utc)
            session.add(poker_hand)
            try:
                session.commit()
            except Exception as e:
                session.rollback()
                current_app.logger.error(f"Error committing hand completion with no showdown players for hand {poker_hand.id}: {e}")
            return # Or return a status indicating no distribution needed/possible.

        # --- 2. Rake Calculation ---
        total_pot_value_before_rake = poker_hand.pot_size_sats or 0
        actual_rake = 0

        # Apply rake only if conditions are met (e.g., flop seen, or always if pot > 0 as per simplified rule)
        # For now, applying if pot > 0 based on table settings.
        # A more advanced rule: if poker_hand.status not in ['preflop', 'completed'] or len(poker_hand.board_cards) > 0
        if total_pot_value_before_rake > 0:
>           rake_percentage = poker_table.rake_percentage if poker_table.rake_percentage is not None else Decimal("0.00")
E           AttributeError: 'User' object has no attribute 'rake_percentage'

utils/poker_helper.py:1540: AttributeError
_______________ TestSlotTester.test_bonus_trigger_and_mechanics ________________

self = <tests.test_slot_tester.TestSlotTester testMethod=test_bonus_trigger_and_mechanics>

    def test_bonus_trigger_and_mechanics(self):
        print("\nRunning test_bonus_trigger_and_mechanics...")
        tester = SlotTester(slot_short_name="test_slot1", num_spins=10, bet_amount_sats=10)
        tester.load_configuration(test_config_base_path=TEST_CONFIG_BASE_PATH)
        tester.initialize_simulation_state()

        # To reliably test bonus, we need to force a grid.
        # This requires modifying how _simulate_one_spin gets its grid, or mocking generate_spin_grid.
        # For this test, let's assume generate_spin_grid can be influenced or mocked.
        # Monkey-patching generate_spin_grid where it's used (in slot_tester module)
        # Need to import the module itself to patch its members
        import casino_be.utils.slot_tester as slot_tester_module
        original_gsg_in_tester_module = slot_tester_module.generate_spin_grid

        try:
            # More extreme grid to ensure scatter count is high
            def mock_generate_trigger_grid(*args, **kwargs):
                print("DEBUG_TEST: Using mock_generate_TRIGGER_grid")
                return [[2,2,2],[2,2,2],[2,2,2]] # Grid with 9 scatters (ID 2)

            slot_tester_module.generate_spin_grid = mock_generate_trigger_grid

>           spin_data_trigger = tester._simulate_one_spin()

tests/test_slot_tester.py:118:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <casino_be.utils.slot_tester.SlotTester object at 0x7f202ed5f730>

    def _simulate_one_spin(self):
        user = self.mock_user
        slot = self.slot_properties # This is our mock Slot object
        game_session = self.mock_session
        bet_amount_sats = self.bet_amount_sats
        game_config = self.game_config

        # Extract necessary configurations from game_config
        game_data = game_config.get('game', {})
        cfg_layout = game_data.get('layout', {})
        cfg_symbols_list = game_data.get('symbols', []) # List of symbol dicts from config
        cfg_symbols_map = {s_cfg['id']: s_cfg for s_cfg in cfg_symbols_list}

        cfg_paylines = game_data.get('paylines', []) # Ensure this key exists or provide default
        if not cfg_paylines: # Older configs might have paylines under layout
            cfg_paylines = cfg_layout.get('paylines', [])


        cfg_rows = slot.num_rows
        cfg_columns = slot.num_columns
        cfg_wild_symbol_id = slot.wild_symbol_id
        cfg_scatter_symbol_id = slot.scatter_symbol_id
        cfg_bonus_features = game_data.get('bonus_features', {}) # Ensure this exists or provide default

        cfg_is_cascading = slot.is_cascading
        cfg_cascade_type = slot.cascade_type
        cfg_min_symbols_to_match = slot.min_symbols_to_match
        cfg_win_multipliers = slot.win_multipliers
        cfg_reel_strips = game_data.get('reel_strips')

        # Betting Logic (Simplified)
        is_bonus_spin = False
        current_spin_multiplier = 1.0
        actual_bet_this_spin = 0

        if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
            is_bonus_spin = True
            actual_bet_this_spin = 0 # Free spin
            current_spin_multiplier = game_session.bonus_multiplier
            game_session.bonus_spins_remaining -= 1
        else:
            is_bonus_spin = False
            actual_bet_this_spin = bet_amount_sats
            current_spin_multiplier = 1.0
            if user.balance < actual_bet_this_spin:
                print("Warning: Mock user has insufficient balance. Stopping simulation.")
                # This case should ideally be handled or decided if it's a test scenario
                return None # Stop simulation if balance runs out
            user.balance -= actual_bet_this_spin

        # Generate Spin Grid
        if not slot.symbols:
            print("ERROR: No symbols loaded into slot_properties.symbols. Cannot generate grid.")
            return None

        spin_result_grid = generate_spin_grid(
            cfg_rows,
            cfg_columns,
            slot.symbols,
            cfg_wild_symbol_id,
            cfg_scatter_symbol_id,
            cfg_symbols_map,
            cfg_reel_strips
        )
        initial_spin_grid_for_record = [row[:] for row in spin_result_grid] # Deep copy

        # Calculate Wins (Initial + Cascades)
        bet_for_calc_win = actual_bet_this_spin if not is_bonus_spin else bet_amount_sats

>       win_info = calculate_win(
            spin_result_grid,
            cfg_paylines,
            cfg_symbols_map,
            bet_for_calc_win, # Base win calculation on original bet for bonus spins too
            cfg_wild_symbol_id,
            cfg_scatter_symbol_id,
            game_data.get('payouts', []),
            cfg_min_symbols_to_match
        )
E       TypeError: calculate_win() takes 7 positional arguments but 8 were given

utils/slot_tester.py:279: TypeError
----------------------------- Captured stdout call -----------------------------

Running test_bonus_trigger_and_mechanics...
INFO: Loading configuration for slot: test_slot1...
INFO: Successfully loaded configuration for Test Slot 1.
INFO: Slot is_cascading: False
INFO: Initialized simulation state: User Balance=1000, Session Spins=0
DEBUG_TEST: Using mock_generate_TRIGGER_grid
__________________ TestSlotTester.test_calculate_win_scatter ___________________

self = <tests.test_slot_tester.TestSlotTester testMethod=test_calculate_win_scatter>

    def test_calculate_win_scatter(self):
        print("\nRunning test_calculate_win_scatter...")
        tester = SlotTester(slot_short_name="test_slot1", num_spins=1, bet_amount_sats=100)
        tester.load_configuration(test_config_base_path=TEST_CONFIG_BASE_PATH)
        game_data = tester.game_config['game']

        grid = [[2,2,2], [1,1,1], [1,1,1]] # Simplified grid: 3 Scatters (ID 2) on first row

        config_paylines = game_data['paylines']
        config_symbols_map = {s['id']: s for s in game_data['symbols']}
        total_bet_sats = 100
        wild_symbol_id = game_data['symbol_wild']
        scatter_symbol_id = game_data['symbol_scatter']

        # Scatter payout for 3 matches of symbol 2 is multiplier 5 (of total bet)
        # Win = total_bet_sats * 5 = 100 * 5 = 500

>       win_info = calculate_win(
            grid, config_paylines, config_symbols_map, total_bet_sats,
            wild_symbol_id, scatter_symbol_id,
            game_data.get('payouts', []), game_data.get('min_symbols_to_match')
        )
E       TypeError: calculate_win() takes 7 positional arguments but 8 were given

tests/test_slot_tester.py:86: TypeError
----------------------------- Captured stdout call -----------------------------

Running test_calculate_win_scatter...
INFO: Loading configuration for slot: test_slot1...
INFO: Successfully loaded configuration for Test Slot 1.
INFO: Slot is_cascading: False
_______________ TestSlotTester.test_calculate_win_simple_payline _______________

self = <tests.test_slot_tester.TestSlotTester testMethod=test_calculate_win_simple_payline>

    def test_calculate_win_simple_payline(self):
        print("\nRunning test_calculate_win_simple_payline...")
        # Load the config to get necessary parameters
        tester = SlotTester(slot_short_name="test_slot1", num_spins=1, bet_amount_sats=30) # 3 lines, 10 per line
        tester.load_configuration(test_config_base_path=TEST_CONFIG_BASE_PATH)
        game_data = tester.game_config['game']

        grid = [[1,1,1], [3,3,3], [3,3,3]] # 3 Cherries (ID 1) on payline 0, no other wins

        config_paylines = game_data['paylines']
        config_symbols_map = {s['id']: s for s in game_data['symbols']}
        total_bet_sats = 30 # Assuming 3 lines, 10 per line, or just a total bet.
                            # calculate_win uses total_bet_sats and derives bet_per_line.
        wild_symbol_id = game_data['symbol_wild']
        scatter_symbol_id = game_data['symbol_scatter']

        # For calculate_win, bet_per_line is derived. If 1 payline, bet_per_line = total_bet
        # If multiple paylines are defined in config and assumed active, it's total_bet / num_paylines
        # Our test_slot1 has 1 payline.
        # Payout for symbol 1, 3 matches is multiplier 10.
        # Win = (total_bet_sats / num_paylines) * multiplier = (30 / 1) * 10 = 300

>       win_info = calculate_win(
            grid, config_paylines, config_symbols_map, total_bet_sats,
            wild_symbol_id, scatter_symbol_id,
            game_data.get('payouts', []), game_data.get('min_symbols_to_match')
        )
E       TypeError: calculate_win() takes 7 positional arguments but 8 were given

tests/test_slot_tester.py:59: TypeError
----------------------------- Captured stdout call -----------------------------

Running test_calculate_win_simple_payline...
INFO: Loading configuration for slot: test_slot1...
INFO: Successfully loaded configuration for Test Slot 1.
INFO: Slot is_cascading: False
_________________ TestSlotTester.test_get_symbol_payout_direct _________________

self = <tests.test_slot_tester.TestSlotTester testMethod=test_get_symbol_payout_direct>

    def test_get_symbol_payout_direct(self):
        print("\nRunning test_get_symbol_payout_direct...")
        # This test needs access to get_symbol_payout, which is in spin_handler
        # Ensure get_symbol_payout is imported:
        # from casino_be.utils.spin_handler import get_symbol_payout

        # Minimal setup to get config_symbols_map
        tester = SlotTester(slot_short_name="test_slot1", num_spins=1, bet_amount_sats=10)
        tester.load_configuration(test_config_base_path=TEST_CONFIG_BASE_PATH)
        game_data = tester.game_config['game']
        config_symbols_map = {s['id']: s for s in game_data['symbols']}

        # Test payline symbol 1, 3 matches
        # Expected multiplier: 10.0 from "value_multipliers": {"3": 10}
        payline_mult = get_symbol_payout(symbol_id=1, count=3, config_symbols_map=config_symbols_map, is_scatter=False)
        self.assertEqual(payline_mult, 10.0, "get_symbol_payout direct for payline symbol 1 failed.")

        # Test scatter symbol 2, 3 matches
        # Expected multiplier: 5.0 from "payouts": {"3": 5}
        scatter_mult = get_symbol_payout(symbol_id=2, count=3, config_symbols_map=config_symbols_map, is_scatter=True)
>       self.assertEqual(scatter_mult, 5.0, "get_symbol_payout direct for scatter symbol 2 failed.")
E       AssertionError: 0.0 != 5.0 : get_symbol_payout direct for scatter symbol 2 failed.

tests/test_slot_tester.py:163: AssertionError
----------------------------- Captured stdout call -----------------------------

Running test_get_symbol_payout_direct...
INFO: Loading configuration for slot: test_slot1...
INFO: Successfully loaded configuration for Test Slot 1.
INFO: Slot is_cascading: False
_______________ TestSlotTester.test_reel_strip_generation_basic ________________

self = <tests.test_slot_tester.TestSlotTester testMethod=test_reel_strip_generation_basic>

    def test_reel_strip_generation_basic(self):
        print("\nRunning test_reel_strip_generation_basic...")
        tester = SlotTester(slot_short_name="test_slot1", num_spins=1, bet_amount_sats=10)
        tester.load_configuration(test_config_base_path=TEST_CONFIG_BASE_PATH)
        tester.initialize_simulation_state()

>       spin_data = tester._simulate_one_spin()

tests/test_slot_tester.py:195:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
utils/slot_tester.py:265: in _simulate_one_spin
    spin_result_grid = generate_spin_grid(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

rows = 3, columns = 3
db_symbols = [<SlotSymbol Cherry (Slot: 999, ID: 1)>, <SlotSymbol ScatterS (Slot: 999, ID: 2)>, <SlotSymbol WildW (Slot: 999, ID: 3)>]
wild_symbol_config_id = 3, scatter_symbol_config_id = 2
config_symbols_map = {1: {'cluster_payouts': {}, 'id': 1, 'name': 'Cherry', 'value': 10, ...}, 2: {'cluster_payouts': {}, 'id': 2, 'name': 'ScatterS', 'payouts': {'3': 5}, ...}, 3: {'cluster_payouts': {}, 'id': 3, 'name': 'WildW', 'value': 0, ...}}
reel_strips = [[1, 1, 1, 2, 3], [1, 1, 1, 2, 3], [1, 1, 1, 2, 3]]

    def generate_spin_grid(rows, columns, db_symbols, wild_symbol_config_id, scatter_symbol_config_id, config_symbols_map, reel_strips=None):
        if not db_symbols:
            # This indicates a setup issue.
            # Fallback to a simple grid if no symbols are defined for the slot in DB.
            s_ids = list(config_symbols_map.keys())
            return [[s_ids[0] if s_ids else 1 for _ in range(columns)] for _ in range(rows)]

        valid_symbol_ids_for_slot = [s.symbol_internal_id for s in db_symbols]
        spinable_symbol_ids = [sid for sid in valid_symbol_ids_for_slot if sid in config_symbols_map]

        if not spinable_symbol_ids:
            raise ValueError("No spinable symbols found. Check slot DB symbol configuration against gameConfig.json.")

        # --- Weighting ---
        # Weights are retrieved from each symbol's 'weight' property in gameConfig.json.
        weights = []
        symbols_for_choice = []

        for s_id in spinable_symbol_ids:
            symbol_config = config_symbols_map.get(s_id)
            if symbol_config:
                raw_weight = symbol_config.get('weight')
                current_weight = 1.0  # Default weight
                if isinstance(raw_weight, (int, float)) and raw_weight > 0:
                    current_weight = float(raw_weight)
                else:
                    # Log a warning here in a real application if weight is missing or invalid for a symbol
                    # print(f"Warning: Symbol ID {s_id} has missing or invalid weight '{raw_weight}'. Defaulting to 1.0.")
                    pass # Using default weight 1.0

                weights.append(current_weight)
                symbols_for_choice.append(s_id)
            else:
                # This case should ideally not be reached if spinable_symbol_ids are derived correctly from config_symbols_map keys
                # Log a warning: Symbol ID {s_id} not found in config_symbols_map, skipping for weighted choice.
                pass


        total_weight = sum(weights)
        if total_weight == 0 or not symbols_for_choice: # Prevent division by zero or empty choices
             if not symbols_for_choice: # if symbols_for_choice is empty, fall back to spinable_symbol_ids with uniform weight
                 if not spinable_symbol_ids: # Should have been caught earlier
                      raise ValueError("Cannot generate spin grid: No symbols available for choice and no spinable_symbol_ids.")
                 symbols_for_choice = spinable_symbol_ids
                 weights = [1.0] * len(symbols_for_choice)
                 total_weight = float(len(symbols_for_choice))
             else: # weights were all zero, distribute uniformly
                 weights = [1.0 / len(symbols_for_choice) for _ in symbols_for_choice]
        else:
            if reel_strips is not None: # It was provided but invalid
                 print("Warning: reel_strips configuration is invalid, does not match column count, or contains non-integer symbol IDs. Falling back to basic weighted random symbol generation.")
            else:
                 print("Warning: reel_strips not found in gameConfig. Falling back to basic weighted random symbol generation.")

            # Fallback to existing (or improved basic weighted) logic
            weights = []
            symbols_for_choice = []

            for s_id in spinable_symbol_ids:
                symbol_config = config_symbols_map.get(s_id)
                if symbol_config: # Should always be true if s_id is from spinable_symbol_ids
                    # Example: use a 'spawn_weight' or 'reel_weight' from config if available
                    # For now, assume equal weight for simplicity, but favor non-special symbols slightly more.
                    is_wild = symbol_config.get('is_wild', False) or s_id == wild_symbol_config_id
                    is_scatter = symbol_config.get('is_scatter', False) or s_id == scatter_symbol_config_id

                    # Default weights if not specified in symbol_config (as 'weight' key)
                    default_weight = 1.0
                    if is_wild: default_weight = 0.5
                    elif is_scatter: default_weight = 0.4

                    weights.append(symbol_config.get('weight', default_weight))
                    symbols_for_choice.append(s_id)

            if not symbols_for_choice: # Should be caught by spinable_symbol_ids check earlier
                 raise ValueError("Cannot generate spin grid: No symbols available for choice in fallback.")

            total_weight = sum(weights)
            if total_weight == 0 : # Prevent division by zero if all weights are zero
                # Fallback to uniform distribution if all weights are zero
                weights = [1.0 / len(symbols_for_choice)] * len(symbols_for_choice)
            else:
                weights = [w / total_weight for w in weights]

            for r_idx in range(rows):
                row_symbols = random.choices(symbols_for_choice, weights=weights, k=columns)
>               grid[r_idx] = row_symbols # Assign directly to the row
E               NameError: name 'grid' is not defined

utils/spin_handler.py:495: NameError
----------------------------- Captured stdout call -----------------------------

Running test_reel_strip_generation_basic...
INFO: Loading configuration for slot: test_slot1...
INFO: Successfully loaded configuration for Test Slot 1.
INFO: Slot is_cascading: False
INFO: Initialized simulation state: User Balance=100, Session Spins=0
Warning: reel_strips configuration is invalid, does not match column count, or contains non-integer symbol IDs. Falling back to basic weighted random symbol generation.
_______________ TestSpinHandler.test_basic_cascade_fall_from_top _______________

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_basic_cascade_fall_from_top>

    def test_basic_cascade_fall_from_top(self):
        # 1. Configure for "fall_from_top" cascading
        self.slot.is_cascading = True
        self.slot.cascade_type = "fall_from_top"
        # Tiered multipliers: 1st cascade x2, 2nd cascade x3
        self.slot.win_multipliers = "[2, 3]" # Stored as JSON string in model

        test_config = {
            "game": {
                **BASE_GAME_CONFIG["game"],
                "is_cascading": True,
                "cascade_type": "fall_from_top",
                "win_multipliers": [2, 3], # e.g. 1st cascade win x2, 2nd x3
                "symbols": [ # Ensure symbols have weights for cascade fill if not mocking fill directly
                    {"id": 1, "name": "SymbolA", "asset": "symA.png", "value_multipliers": {"3": 10}, "weight": 10},
                    {"id": 2, "name": "SymbolB", "asset": "symB.png", "value_multipliers": {"3": 5}, "weight": 20},
                    {"id": 3, "name": "SymbolC", "asset": "symC.png", "value_multipliers": {"3": 2}, "weight": 30},
                    {"id": 5, "name": "Wild", "asset": "wild.png", "weight": 3}
                ],
                 "paylines": [{"id": "line_1", "positions": [[1,0],[1,1],[1,2]]}] # Simplified 3-symbol payline
            }
        }
        self.mock_load_config.return_value = test_config

        # 2. Control symbol generation
        initial_grid_cascade = [
            [1, 1, 1, 2, 3], # This line will fall and win again (SymbolA, id=1)
            [2, 2, 2, 3, 1], # Initial Win here: 3xB (id=2) on payline [[1,0],[1,1],[1,2]]
            [3, 3, 3, 1, 2]
        ]
        self.mock_generate_grid.return_value = initial_grid_cascade

        # When the 3 '2's (SymbolB) are removed from row 1 (index 1),
        # the 3 '1's (SymbolA) from row 0 (index 0) will fall into place on row 1.
        # Then, row 0 becomes empty and needs new symbols.
        # Let these new symbols for row 0, cols 0,1,2 be [3,3,3] (SymbolC, no win on the payline).
        # self.mock_choices is used by handle_cascade_fill. It's called for each new symbol.
        # Since 3 symbols are needed to fill the top row (cols 0, 1, 2 after fall).
        self.mock_choices.side_effect = [
            [[3]], # New symbol for grid[0][0]
            [[3]], # New symbol for grid[0][1]
            [[3]], # New symbol for grid[0][2]
        ]

        bet_amount = 100
        initial_balance = self.user.balance

        # Calculations:
        # Initial win: 3x SymbolB (id=2) on payline. SymbolB pays 5x for 3. Win = 100 * 5 = 500.
        # Cascade 1: Symbols [1,1,1] (SymbolA) fall into the payline. SymbolA (id=1) pays 10x for 3.
        #            Raw win from this cascade = 100 * 10 = 1000.
        #            Multiplier for 1st cascade (level_counter=1) is win_multipliers[0] = 2.
        #            Actual win from 1st cascade = 1000 * 2 = 2000.
        # Total after Cascade 1 = 500 (initial) + 2000 = 2500.
        # Cascade 2: Symbols [3,3,3] (SymbolC) fill the top row. They don't form a win on the defined payline. Cascade stops.
        # Expected total win = 2500.
        expected_total_win = 2500
        expected_multiplier_level = 1 # Max cascade_level_counter that resulted in a win was 1.

        result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

>       self.assertEqual(result['win_amount_sats'], expected_total_win)
E       AssertionError: 0 != 2500

tests/test_spin_handler.py:223: AssertionError
_____________ TestSpinHandler.test_basic_cascade_replace_in_place ______________

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_basic_cascade_replace_in_place>

    def test_basic_cascade_replace_in_place(self):
        self.slot.is_cascading = True
        self.slot.cascade_type = "replace_in_place"
        self.slot.win_multipliers = "[2, 3]"

        test_config_replace = {
            "game": {
                **BASE_GAME_CONFIG["game"],
                "is_cascading": True,
                "cascade_type": "replace_in_place",
                "win_multipliers": [2, 3],
                "symbols": [
                    {"id": 1, "name": "SymbolA", "asset": "symA.png", "value_multipliers": {"3": 10}, "weight": 10}, # Wins
                    {"id": 2, "name": "SymbolB", "asset": "symB.png", "value_multipliers": {"3": 5}, "weight": 20},  # Initial win
                    {"id": 3, "name": "SymbolC", "asset": "symC.png", "value_multipliers": {"3": 2}, "weight": 30},  # No win
                ],
                "paylines": [{"id": "line_1", "positions": [[1,0],[1,1],[1,2]]}]
            }
        }
        self.mock_load_config.return_value = test_config_replace

        initial_grid_cascade_replace = [
            [3, 3, 3, 2, 3],
            [2, 2, 2, 3, 1], # Initial Win here: 3xB (id=2) on payline [[1,0],[1,1],[1,2]]
            [1, 1, 3, 1, 2]
        ]
        self.mock_generate_grid.return_value = initial_grid_cascade_replace

        # Symbols for "replace_in_place":
        # The winning symbols [2,2,2] at positions (1,0), (1,1), (1,2) will be replaced.
        # Let the new symbols be [1,1,1] (SymbolA) to cause a cascade win.
        # Then, for the next cascade, let the new symbols be [3,3,3] (SymbolC) to stop.
        self.mock_choices.side_effect = [
            [[1]], # New symbol for grid[1][0] (replaces a '2')
            [[1]], # New symbol for grid[1][1] (replaces a '2')
            [[1]], # New symbol for grid[1][2] (replaces a '2')
            # Second cascade fill (after [1,1,1] win)
            [[3]], # New symbol for grid[1][0]
            [[3]], # New symbol for grid[1][1]
            [[3]], # New symbol for grid[1][2]
        ]

        bet_amount = 100
        initial_balance = self.user.balance

        # Calculations:
        # Initial win: 3x SymbolB (id=2). Pays 5x. Win = 100 * 5 = 500.
        # Cascade 1: [1,1,1] (SymbolA) replace [2,2,2]. SymbolA pays 10x for 3.
        #            Raw win = 100 * 10 = 1000.
        #            Multiplier for 1st cascade is 2. Actual win = 1000 * 2 = 2000.
        # Total after Cascade 1 = 500 + 2000 = 2500.
        # Cascade 2: [3,3,3] (SymbolC) replace [1,1,1]. SymbolC is not on payline or doesn't make a line. No win.
        expected_total_win = 2500
        expected_multiplier_level = 1 # Max cascade_level_counter resulting in a win.

        result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

>       self.assertEqual(result['win_amount_sats'], expected_total_win)
E       AssertionError: 0 != 2500

tests/test_spin_handler.py:296: AssertionError
__________ TestSpinHandler.test_cluster_win_multiple_wilds_no_cascade __________

user = <[DetachedInstanceError('Instance <User at 0x7f202ef0d5d0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202ef0d5d0>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202ef0f760> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202ef0f760>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202ef0cd30> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202ef0cd30>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
>           win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

utils/spin_handler.py:171:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

grid = [[1, 1, 2, 3, 5], [1, 5, 3, 2, 3], [3, 2, 3, 4, 3]], config_paylines = []
config_symbols_map = {1: {'asset': 'symA.png', 'cluster_payouts': {'5': 15.0}, 'id': 1, 'name': 'SymbolA', ...}, 2: {'asset': 'symB.png', '...bolC', 'weight': 30.0}, 4: {'asset': 'scatter.png', 'id': 4, 'name': 'Scatter', 'scatter_payouts': {'3': 5}, ...}, ...}
total_bet_sats = 100, wild_symbol_id = 5, scatter_symbol_id = 4
min_symbols_to_match = 5

    def calculate_win(grid, config_paylines, config_symbols_map, total_bet_sats, wild_symbol_id, scatter_symbol_id, min_symbols_to_match): # Removed current_spin_multiplier and general config_payouts
        """Calculates total win amount and identifies winning lines using config.
        `config_paylines` is game_config.game.layout.paylines
        `config_symbols_map` is game_config.game.symbols (mapped by id), used for symbol properties and payouts.
        `total_bet_sats` is the total amount bet for the entire spin.
        `wild_symbol_id` is the internal ID from config.
        `scatter_symbol_id` is the internal ID from config.
        `min_symbols_to_match` (from game_config.game.min_symbols_to_match) is for "Match N" or cluster logic.
        """
        # print(f"DEBUG_TEST_HANDLER: calculate_win called with total_bet_sats={total_bet_sats}") # Debug
        total_win_sats = 0
        winning_lines_data = [] # Store detailed info about each win
        all_winning_symbol_coords = set() # Using a set to store unique [r,c] tuples for removal
        num_rows = len(grid)
        num_cols = len(grid[0]) if num_rows > 0 else 0

        # --- Payline Wins ---
        # Bet per line calculation:
        num_active_paylines = len(config_paylines) # Assuming all defined paylines are played
        if num_active_paylines == 0:
            bet_per_line_sats = 0 # Avoid division by zero; though should not happen with valid config
        else:
            # Ensure integer division, handle potential rounding if necessary (though satoshis should be precise)
            bet_per_line_sats = total_bet_sats // num_active_paylines
            # It's possible that total_bet_sats is not perfectly divisible.
            # Game design should specify how this is handled (e.g. user bets per line, or total bet must be multiple of lines)
            # For now, we assume total_bet_sats is what's wagered, and bet_per_line is derived.
        # print(f"DEBUG_TEST_HANDLER: num_active_paylines={num_active_paylines}, bet_per_line_sats={bet_per_line_sats}") # Debug

        for payline_config in config_paylines:
            payline_id = payline_config.get("id", "unknown_line")
            payline_positions = payline_config.get("coords", []) # List of [row, col] #FIX: Changed "positions" to "coords"

            line_symbols_on_grid = [] # Actual symbol IDs on this payline from the spin grid
            actual_positions_on_line = [] # Coordinates of these symbols

            for r, c in payline_positions:
                if 0 <= r < num_rows and 0 <= c < num_cols:
                    symbol_on_grid = grid[r][c]
                    line_symbols_on_grid.append(symbol_on_grid)
                    actual_positions_on_line.append([r,c])
                else: # Should not happen with valid config
                    line_symbols_on_grid.append(None) # Placeholder for out-of-bounds
                    actual_positions_on_line.append(None)

            # Determine winning symbol and count for this line (left-to-right)
            first_symbol_on_line = line_symbols_on_grid[0]
            if first_symbol_on_line is None or first_symbol_on_line == scatter_symbol_id:
                continue # Paylines typically don't start with scatter or empty positions

            match_symbol_id = None
            consecutive_count = 0
            winning_symbol_positions = []

            # Handle if the line starts with a wild symbol
            if first_symbol_on_line == wild_symbol_id:
                # Wilds substitute for other symbols. Need to find the first non-wild to determine the matching symbol.
                # Then count initial wilds + subsequent matching symbols or wilds.
                temp_match_symbol_id = None
                wilds_at_start = 0
                for i in range(len(line_symbols_on_grid)):
                    s_id = line_symbols_on_grid[i]
                    if s_id == wild_symbol_id:
                        wilds_at_start += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    elif s_id != scatter_symbol_id : # Found the symbol to match
                        temp_match_symbol_id = s_id
                        consecutive_count = wilds_at_start + 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                        match_symbol_id = temp_match_symbol_id
                        break
                    else: # Scatter or None, breaks payline continuity for this potential match
                        break

                if match_symbol_id is None and wilds_at_start > 0: # Line is all wilds (or wilds then scatter/None)
                    # If game rules allow all-wild lines, determine payout for wild symbol itself
                    # Wild symbol must have its own entry in 'value_multipliers' in config
                    symbol_config = config_symbols_map.get(wild_symbol_id)
                    if symbol_config and symbol_config.get('value_multipliers'):
                        match_symbol_id = wild_symbol_id
                        consecutive_count = wilds_at_start
                    else: # Wilds don't form their own win, or line too short
                        continue
            else:
                # Line starts with a regular symbol
                match_symbol_id = first_symbol_on_line
                consecutive_count = 1
                winning_symbol_positions.append(actual_positions_on_line[0])

            # Continue counting from the position after initial sequence
            # If first symbol was wild and found a match, `consecutive_count` is already set.
            # `i` should start from `consecutive_count` index in `line_symbols_on_grid`.
            if match_symbol_id: # Proceed if a potential winning line is identified
                for i in range(consecutive_count, len(line_symbols_on_grid)):
                    current_symbol_on_grid = line_symbols_on_grid[i]
                    if current_symbol_on_grid == match_symbol_id or current_symbol_on_grid == wild_symbol_id:
                        consecutive_count += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    else:
                        break # Sequence broken

            # Get payout for the matched sequence
            # The minimum match count is implicitly handled by what's defined in value_multipliers (e.g. no "1" or "2")
            payout_multiplier = get_symbol_payout(match_symbol_id, consecutive_count, config_symbols_map, is_scatter=False)
            # print(f"DEBUG_TEST_HANDLER: Payline {payline_id}, Symbol {match_symbol_id}, Count {consecutive_count}, PayoutMultiplier {payout_multiplier}") # Debug

            if payout_multiplier > 0:
                # Line win = bet_per_line * symbol_multiplier
                # Ensure bet_per_line_sats is used here.
                line_win_sats = int(bet_per_line_sats * payout_multiplier)

                # Apply spin multiplier if any (e.g. from free spins bonus)
                # This is now handled outside, after all raw wins are calculated.
                # line_win_sats = int(line_win_sats * current_spin_multiplier)


                if line_win_sats > 0:
                    total_win_sats += line_win_sats
                    winning_lines_data.append({
                        "line_id": payline_id, # From payline config
                        "symbol_id": match_symbol_id, # The symbol that formed the win (not wild, unless wild itself pays)
                        "count": consecutive_count,
                        "positions": winning_symbol_positions, # List of [r,c] coordinates
                        "win_amount_sats": line_win_sats
                    })
                    for pos in winning_symbol_positions:
                        all_winning_symbol_coords.add(tuple(pos))

        # --- Scatter Wins ---
        # (This part remains largely the same but contributes to all_winning_symbol_coords)
        scatter_positions_on_grid = []
        scatter_count_on_grid = 0
        if scatter_symbol_id is not None: # Check if a scatter symbol is configured
            for r_idx, row in enumerate(grid):
                for c_idx, symbol_in_cell in enumerate(row):
                    if symbol_in_cell == scatter_symbol_id:
                        scatter_count_on_grid += 1
                        scatter_positions_on_grid.append([r_idx, c_idx])

        # Get scatter payout based on count
        # Scatter payouts are typically multiples of the *total bet*
        scatter_payout_multiplier = get_symbol_payout(scatter_symbol_id, scatter_count_on_grid, config_symbols_map, is_scatter=True)

        if scatter_payout_multiplier > 0:
            scatter_win_sats = int(total_bet_sats * scatter_payout_multiplier)
            # scatter_win_sats = int(scatter_win_sats * current_spin_multiplier) # Apply spin multiplier - also handled outside now

            if scatter_win_sats > 0:
                total_win_sats += scatter_win_sats
                winning_lines_data.append({
                    "line_id": "scatter", # Special identifier for scatter wins
                    "symbol_id": scatter_symbol_id,
                    "count": scatter_count_on_grid,
                    "positions": scatter_positions_on_grid,
                    "win_amount_sats": scatter_win_sats
                })
                for pos in scatter_positions_on_grid: # Add scatter symbol positions for removal
                    all_winning_symbol_coords.add(tuple(pos))

        # --- TODO: Implement "Match N" / Cluster Pays Logic ---
        # If cfg_min_symbols_to_match is not None:
        #   1. Count all symbol occurrences on the grid.
        #   2. For symbols meeting cfg_min_symbols_to_match:
        #      a. Find their positions.
        #      b. Calculate win based on cfg_payouts (needs a specific structure for this type of win).
        #      c. Add to total_win_sats, winning_lines_data, and all_winning_symbol_coords.
        # This section will be complex and require careful handling of payout definitions.
        # For now, this placeholder indicates where it would go.

        # --- "Match N" / Cluster Pays Logic ---
        # This logic assumes "anywhere on grid" for clusters, and wilds contribute to any cluster they can help form.
        if min_symbols_to_match is not None and min_symbols_to_match > 0:
            symbol_counts = {}
            symbol_positions_map = {} # Stores list of positions for each symbol_id (excluding wilds initially)

            # Count literal symbols and their positions (excluding wilds for base count)
            for r, row_data in enumerate(grid):
                for c, s_id_in_cell in enumerate(row_data):
                    if s_id_in_cell is None: continue

                    # For cluster base counts, we only consider non-wild, non-scatter symbols here.
                    # Wilds are counted separately and added to effective counts.
                    # Scatters are typically handled by their own independent payout logic.
                    if s_id_in_cell != wild_symbol_id and s_id_in_cell != scatter_symbol_id:
                        symbol_counts[s_id_in_cell] = symbol_counts.get(s_id_in_cell, 0) + 1
                        if s_id_in_cell not in symbol_positions_map:
                            symbol_positions_map[s_id_in_cell] = []
                        symbol_positions_map[s_id_in_cell].append([r, c])

            # Count total wilds on the grid and their positions
            num_wilds_on_grid = 0
            wild_positions_on_grid = []
            if wild_symbol_id is not None:
                for r_idx, row_data in enumerate(grid):
                    for c_idx, s_id_in_cell in enumerate(row_data):
                        if s_id_in_cell == wild_symbol_id:
                            num_wilds_on_grid += 1
                            wild_positions_on_grid.append([r_idx, c_idx])

            for symbol_id, literal_symbol_count in symbol_counts.items():
                # Wilds do not form their own cluster type; they assist other symbols.
                # Scatter symbols are handled by their dedicated scatter win logic, not cluster logic here.
                if symbol_id == wild_symbol_id or symbol_id == scatter_symbol_id: # Should already be excluded by map population
                    continue

                effective_count = literal_symbol_count + num_wilds_on_grid

                if effective_count >= min_symbols_to_match:
                    # This symbol forms a "match N" win with the help of wilds.
                    # `config_payouts` is a list of dicts. We need to find the relevant one.
                    # Example structure for a cluster payout entry in `config_payouts`:
                    # { "type": "cluster", "symbol_id": <ID>, "matches": <N>, "multiplier": <X_per_symbol_or_fixed> }
                    # Or payouts might be within the symbol definition in `config_symbols_map`
                    # e.g. config_symbols_map[symbol_id].get('cluster_payouts', {}).get(str(effective_count))

                    payout_value_for_cluster = 0
                    symbol_config_data = config_symbols_map.get(symbol_id, {})
                    cluster_payout_rules = symbol_config_data.get('cluster_payouts', {}) # e.g. {"8": 100, "9": 150}

                    if cluster_payout_rules:
                        # The key in cluster_payouts is the string representation of the effective_count.
                        payout_value_for_cluster = cluster_payout_rules.get(str(effective_count), 0.0)

                    # Attempt 2: Fallback or alternative - search generic `config_payouts` list
                    # This is less direct. The gameConfig structure needs to be clear.
                    # if not payout_value_for_cluster:
                    #     for payout_rule in config_payouts:
                    #         if payout_rule.get("type") == "cluster" and \
                    #            payout_rule.get("symbol_id") == symbol_id and \
                    #            payout_rule.get("matches") == count:
                    #             payout_value_for_cluster = payout_rule.get("multiplier", 0.0)
                    #             break

                    if payout_value_for_cluster > 0:
                        # Cluster win amount calculation.
                        # Cluster win calculation: total_bet_sats * payout_value_for_cluster.
                        # This assumes the payout_value_for_cluster is a direct multiplier of the total bet for that cluster.
                        cluster_win_sats_this_group = int(total_bet_sats * payout_value_for_cluster)

                        if cluster_win_sats_this_group > 0:
>                           print(f"DEBUG: Cluster win for symbol {symbol_id} count {count} with multiplier {payout_value_for_cluster}. Win: {cluster_win_sats_this_group}")
E                           NameError: name 'count' is not defined

utils/spin_handler.py:782: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_cluster_win_multiple_wilds_no_cascade>

    def test_cluster_win_multiple_wilds_no_cascade(self):
        min_match = 5
        payouts_sym1 = {"5": 15.0}
        self.helper_configure_cluster_game(min_match=min_match, cluster_payouts_sym1=payouts_sym1)

        # Grid: 3 SymbolA (id=1), 2 Wilds (id=5)
        test_grid = [
            [1, 1, 2, 3, 5], # Wild at (0,4)
            [1, 5, 3, 2, 3], # Wild at (1,1)
            [3, 2, 3, 4, 3]
        ]
        self.mock_generate_grid.return_value = test_grid
        bet_amount = 100
        expected_win = 100 * 15.0 # 1500

>       result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

tests/test_spin_handler.py:564:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user = <[DetachedInstanceError('Instance <User at 0x7f202ef0d5d0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202ef0d5d0>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202ef0f760> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202ef0f760>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202ef0cd30> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202ef0cd30>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
            win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

            # Initial win calculation results
            initial_raw_win_sats = win_info['total_win_sats']
            winning_lines = win_info['winning_lines'] # From initial spin
            current_winning_coords = win_info['winning_symbol_coords'] # Coords from initial spin

            # Store initial grid for SlotSpin record
            initial_spin_grid_for_record = [row[:] for row in spin_result_grid] # Deep copy

            # Initialize total win & state for potential cascades
            total_win_for_entire_spin_sequence_raw = initial_raw_win_sats # Accumulates RAW wins (base + cascades without cascade multipliers)
                                                                    # This will then be multiplied by bonus_spin_multiplier if applicable.
                                                                    # OR, this accumulates wins *with* cascade multipliers, then gets *bonus_spin_multiplier*.
                                                                    # Let's use: sum of (raw_win * cascade_level_multiplier)

            # Let total_win_for_entire_spin_sequence represent the sum of:
            # (initial_raw_win) + (cascade1_raw_win * mult1) + (cascade2_raw_win * mult2) ...
            total_win_for_entire_spin_sequence = initial_raw_win_sats # Initial win has effective cascade multiplier of 1 or none.

            current_grid_state = spin_result_grid # This grid will be modified in cascades
            current_raw_win_for_cascade_loop = initial_raw_win_sats # Controls cascade loop continuation based on raw win of previous step

            max_cascade_multiplier_level_achieved = 0 # For SlotSpin.current_multiplier_level (tracks highest cfg_win_multipliers index used +1)
                                                 # Or simply the highest multiplier value achieved. Let's use the level for now.

            # --- Cascading Wins Logic ---
            if cfg_is_cascading and initial_raw_win_sats > 0 and current_winning_coords:
                cascade_level_counter = 0 # 0 means initial win, 1st cascade is level 1, etc.

                while current_raw_win_for_cascade_loop > 0 and current_winning_coords:
                    # 1. Grid Update: Remove winning symbols, fill new ones
                    current_grid_state = handle_cascade_fill(
                        current_grid_state,
                        current_winning_coords, # Coords from the previous win calculation
                        cfg_cascade_type,
                        slot.symbols, # db_symbols
                        cfg_symbols_map,
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id
                    )

                    # 2. Recalculate Wins on the new grid
                    cascade_win_info = calculate_win(
                        current_grid_state, # The newly formed grid
                        cfg_paylines,
                        cfg_symbols_map,
                        bet_amount_sats, # Base bet amount for calculating wins
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id,
                        # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                        cfg_min_symbols_to_match
                    )

                    new_raw_win_this_cascade = cascade_win_info['total_win_sats']
                    current_winning_coords = cascade_win_info['winning_symbol_coords'] # For the next iteration's fill

                    if new_raw_win_this_cascade > 0:
                        cascade_level_counter += 1 # This is the 1st, 2nd, etc. cascade event

                        current_cascade_multiplier = 1.0
                        if cfg_win_multipliers: # Check if win_multipliers are defined and non-empty
                            if cascade_level_counter -1 < len(cfg_win_multipliers): # cfg_win_multipliers is 0-indexed
                                current_cascade_multiplier = cfg_win_multipliers[cascade_level_counter -1]
                            elif cfg_win_multipliers: # Not empty, so use last available
                                current_cascade_multiplier = cfg_win_multipliers[-1]

                        if cascade_level_counter > max_cascade_multiplier_level_achieved: # Using counter as level proxy
                            max_cascade_multiplier_level_achieved = cascade_level_counter

                        # Add the (raw_win_from_this_cascade * its_cascade_multiplier) to the grand total
                        total_win_for_entire_spin_sequence += int(new_raw_win_this_cascade * current_cascade_multiplier)

                        current_raw_win_for_cascade_loop = new_raw_win_this_cascade # Keep loop going if there was a raw win

                        # Accumulate winning_lines (optional, can make response large)
                        # winning_lines.extend(cascade_win_info['winning_lines']) # Example if needed
                    else:
                        current_raw_win_for_cascade_loop = 0 # No new raw win, so stop cascading
                        current_winning_coords = [] # Clear coords
                # End of cascade loop

            # Now, total_win_for_entire_spin_sequence holds sum of (initial_raw + C1_raw*M1 + C2_raw*M2 ...)
            # Apply overall bonus spin multiplier if applicable (e.g., from free spins feature)
            final_win_amount_for_session_and_tx = total_win_for_entire_spin_sequence
            if is_bonus_spin and current_spin_multiplier > 1.0:
                final_win_amount_for_session_and_tx = int(total_win_for_entire_spin_sequence * current_spin_multiplier)
                # Note: if winning_lines are accumulated, their individual win_amount_sats would also need scaling
                # if a detailed breakdown of multiplied lines is required. Currently, `winning_lines` primarily reflects initial spin.

            # --- Check for Bonus Trigger (on non-bonus spins) ---
            # Bonus trigger check should be based on the *initial* spin grid results.
            bonus_triggered_this_spin = False
            newly_awarded_spins = 0
            new_bonus_multiplier = 1.0

            if not is_bonus_spin: # Bonus can only be triggered on a normal spin
                bonus_trigger_info = check_bonus_trigger(
                    initial_spin_grid_for_record, # Check on the initial grid
                    cfg_scatter_symbol_id,
                    cfg_bonus_features
                )
                if bonus_trigger_info['triggered']:
                    bonus_triggered_this_spin = True
                    newly_awarded_spins = bonus_trigger_info.get('spins_awarded', 0)
                    new_bonus_multiplier = bonus_trigger_info.get('multiplier', 1.0)


            # --- Update Session State for Bonus ---
            if bonus_triggered_this_spin:
                if not game_session.bonus_active: # Starting a new bonus
                    game_session.bonus_active = True
                    game_session.bonus_spins_remaining = newly_awarded_spins
                    game_session.bonus_multiplier = new_bonus_multiplier
                else: # Re-trigger or additional spins during an active bonus
                    game_session.bonus_spins_remaining += newly_awarded_spins
                    # Optionally, decide if multiplier updates or accumulates, based on game rules
                    # For now, assume it takes the new multiplier if retriggered, or keeps existing if just adding spins.
                    if new_bonus_multiplier != game_session.bonus_multiplier and newly_awarded_spins > 0 :
                         game_session.bonus_multiplier = new_bonus_multiplier # Or max(game_session.bonus_multiplier, new_bonus_multiplier)

            elif game_session.bonus_active and game_session.bonus_spins_remaining <= 0:
                # Bonus ended
                game_session.bonus_active = False
                game_session.bonus_multiplier = 1.0 # Reset multiplier


            # --- Update Session Aggregates ---
            game_session.num_spins += 1
            if not is_bonus_spin:
                game_session.amount_wagered = (game_session.amount_wagered or 0) + actual_bet_this_spin
            # `game_session.amount_won` is updated with the final win amount from this spin.
            # The previous logic added `win_amount_sats` (which was initial win pre-bonus mult).
            # We need to correct this if it was already added, or ensure it's added correctly once.
            # Assuming it was added: subtract old, add new.
            # If it wasn't added yet by this point, just add new.
            # The line `game_session.amount_won = (game_session.amount_won or 0) + win_amount_sats` was there.
            # So, we subtract that `win_amount_sats` (which is `initial_raw_win_sats` potentially multiplied by bonus_multiplier)
            # and add `final_win_amount_for_session_and_tx`.

            # Correction: The `win_amount_sats` that was added to `game_session.amount_won`
            # was the one *after* `if is_bonus_spin and current_spin_multiplier > 1.0:` block.
            # This means it was `initial_raw_win_sats * current_spin_multiplier` if bonus, else `initial_raw_win_sats`.
            # Let's denote this value as `previously_added_win_to_session`.
            previously_added_win_to_session = initial_raw_win_sats
            if is_bonus_spin and current_spin_multiplier > 1.0: # This replicates the original multiplication
                 previously_added_win_to_session = int(initial_raw_win_sats * current_spin_multiplier)

            game_session.amount_won = (game_session.amount_won or 0) - previously_added_win_to_session + final_win_amount_for_session_and_tx


            # --- Update User Balance & Win Transaction ---
            if final_win_amount_for_session_and_tx > 0:
                user.balance += final_win_amount_for_session_and_tx # Add final total win to user balance
                win_tx = Transaction(
                    user_id=user.id,
                    amount=final_win_amount_for_session_and_tx,
                    transaction_type='win',
                    details={
                        'slot_name': slot.name,
                        'session_id': game_session.id,
                        'is_cascade_win': cfg_is_cascading and max_cascade_multiplier_level_achieved > 0,
                        'initial_win': initial_raw_win_sats,
                        'total_cascade_win_multiplied': total_win_for_entire_spin_sequence - initial_raw_win_sats,
                        'bonus_spin_multiplier_applied': current_spin_multiplier if is_bonus_spin else 1.0
                        }
                        # game_session_id removed
                )
                db.session.add(win_tx)
                # game_session.transactions.append(win_tx) # If using relationship for this

            # --- Create Spin Record ---
            new_spin = SlotSpin(
                game_session_id=game_session.id,
                spin_result=initial_spin_grid_for_record, # Record the initial grid
                win_amount=final_win_amount_for_session_and_tx, # Total win from initial + all cascades (with all multipliers)
                bet_amount=actual_bet_this_spin,
                is_bonus_spin=is_bonus_spin,
                spin_time=datetime.now(timezone.utc),
                current_multiplier_level=max_cascade_multiplier_level_achieved # Store max cascade level reached
            )
            db.session.add(new_spin)
            # Crucially, flush here to get new_spin.id before assigning to transactions
            db.session.flush()

            # Link transactions to this spin
            if not is_bonus_spin and 'wager_tx' in locals() and wager_tx: # Ensure wager_tx exists
                wager_tx.slot_spin_id = new_spin.id
                wager_tx.details['slot_spin_id'] = new_spin.id
            if final_win_amount_for_session_and_tx > 0 and 'win_tx' in locals() and win_tx: # Ensure win_tx exists
                win_tx.slot_spin_id = new_spin.id
                win_tx.details['slot_spin_id'] = new_spin.id

            # --- Return Results ---
            # Ensure all satoshi amounts are integers
            return {
                "spin_result": initial_spin_grid_for_record, # Return the initial grid state
                "win_amount_sats": int(final_win_amount_for_session_and_tx),
                "winning_lines": winning_lines, # This currently holds results from the *initial* spin.
                                                # For a full breakdown, this would need to be an accumulation if cascades add more lines.
                "bonus_triggered": bonus_triggered_this_spin,
                "bonus_active": game_session.bonus_active,
                "bonus_spins_remaining": game_session.bonus_spins_remaining if game_session.bonus_active else 0,
                "bonus_multiplier": game_session.bonus_multiplier if game_session.bonus_active else 1.0,
                "user_balance_sats": int(user.balance),
                "session_stats": { # Consistent with other game types potentially
                    "num_spins": game_session.num_spins,
                    "amount_wagered_sats": int(game_session.amount_wagered or 0),
                    "amount_won_sats": int(game_session.amount_won or 0),
                }
            }
        except FileNotFoundError as e:
            # Log error appropriately
            # raise ValueError(f"Game configuration error: {e}") # Or handle more gracefully
            # For now, re-raise as ValueError for the route to catch
            # In a real app, you might want a more specific exception type.
            db.session.rollback() # Rollback any DB changes if config fails
            raise ValueError(str(e))
        except ValueError as e: # Catch specific errors like insufficient balance
            db.session.rollback()
            raise e # Re-raise it for the route to handle
        except Exception as e:
            db.session.rollback()
            # Log the exception e
            # Consider what to return or raise. A generic error for the user.
>           raise RuntimeError(f"An unexpected error occurred during the spin: {str(e)}") # Use str(e) for cleaner message
E           RuntimeError: An unexpected error occurred during the spin: name 'count' is not defined

utils/spin_handler.py:406: RuntimeError
_____________ TestSpinHandler.test_cluster_win_no_wilds_no_cascade _____________

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_cluster_win_no_wilds_no_cascade>

    def test_cluster_win_no_wilds_no_cascade(self):
        min_match = 4
        payouts_sym1 = {"4": 10.0} # 10x for 4 SymbolA
        self.helper_configure_cluster_game(min_match=min_match, cluster_payouts_sym1=payouts_sym1)

        # Grid: 4 SymbolA (id=1)
        test_grid = [
            [1, 1, 2, 3, 2],
            [1, 1, 3, 2, 3],
            [3, 2, 3, 4, 5]
        ]
        self.mock_generate_grid.return_value = test_grid
        bet_amount = 100
        expected_win = 100 * 10.0 # 1000

        result = handle_spin(self.user, self.slot, self.game_session, bet_amount)
>       self.assertEqual(result['win_amount_sats'], expected_win)
E       AssertionError: 0 != 1000.0

tests/test_spin_handler.py:521: AssertionError
_____________ TestSpinHandler.test_cluster_win_one_wild_no_cascade _____________

user = <[DetachedInstanceError('Instance <User at 0x7f202ebca5f0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202ebca5f0>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202ebc8b50> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202ebc8b50>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202ebca470> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202ebca470>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
>           win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

utils/spin_handler.py:171:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

grid = [[1, 1, 2, 3, 2], [1, 1, 3, 2, 3], [5, 2, 3, 4, 3]], config_paylines = []
config_symbols_map = {1: {'asset': 'symA.png', 'cluster_payouts': {'5': 15.0}, 'id': 1, 'name': 'SymbolA', ...}, 2: {'asset': 'symB.png', '...bolC', 'weight': 30.0}, 4: {'asset': 'scatter.png', 'id': 4, 'name': 'Scatter', 'scatter_payouts': {'3': 5}, ...}, ...}
total_bet_sats = 100, wild_symbol_id = 5, scatter_symbol_id = 4
min_symbols_to_match = 5

    def calculate_win(grid, config_paylines, config_symbols_map, total_bet_sats, wild_symbol_id, scatter_symbol_id, min_symbols_to_match): # Removed current_spin_multiplier and general config_payouts
        """Calculates total win amount and identifies winning lines using config.
        `config_paylines` is game_config.game.layout.paylines
        `config_symbols_map` is game_config.game.symbols (mapped by id), used for symbol properties and payouts.
        `total_bet_sats` is the total amount bet for the entire spin.
        `wild_symbol_id` is the internal ID from config.
        `scatter_symbol_id` is the internal ID from config.
        `min_symbols_to_match` (from game_config.game.min_symbols_to_match) is for "Match N" or cluster logic.
        """
        # print(f"DEBUG_TEST_HANDLER: calculate_win called with total_bet_sats={total_bet_sats}") # Debug
        total_win_sats = 0
        winning_lines_data = [] # Store detailed info about each win
        all_winning_symbol_coords = set() # Using a set to store unique [r,c] tuples for removal
        num_rows = len(grid)
        num_cols = len(grid[0]) if num_rows > 0 else 0

        # --- Payline Wins ---
        # Bet per line calculation:
        num_active_paylines = len(config_paylines) # Assuming all defined paylines are played
        if num_active_paylines == 0:
            bet_per_line_sats = 0 # Avoid division by zero; though should not happen with valid config
        else:
            # Ensure integer division, handle potential rounding if necessary (though satoshis should be precise)
            bet_per_line_sats = total_bet_sats // num_active_paylines
            # It's possible that total_bet_sats is not perfectly divisible.
            # Game design should specify how this is handled (e.g. user bets per line, or total bet must be multiple of lines)
            # For now, we assume total_bet_sats is what's wagered, and bet_per_line is derived.
        # print(f"DEBUG_TEST_HANDLER: num_active_paylines={num_active_paylines}, bet_per_line_sats={bet_per_line_sats}") # Debug

        for payline_config in config_paylines:
            payline_id = payline_config.get("id", "unknown_line")
            payline_positions = payline_config.get("coords", []) # List of [row, col] #FIX: Changed "positions" to "coords"

            line_symbols_on_grid = [] # Actual symbol IDs on this payline from the spin grid
            actual_positions_on_line = [] # Coordinates of these symbols

            for r, c in payline_positions:
                if 0 <= r < num_rows and 0 <= c < num_cols:
                    symbol_on_grid = grid[r][c]
                    line_symbols_on_grid.append(symbol_on_grid)
                    actual_positions_on_line.append([r,c])
                else: # Should not happen with valid config
                    line_symbols_on_grid.append(None) # Placeholder for out-of-bounds
                    actual_positions_on_line.append(None)

            # Determine winning symbol and count for this line (left-to-right)
            first_symbol_on_line = line_symbols_on_grid[0]
            if first_symbol_on_line is None or first_symbol_on_line == scatter_symbol_id:
                continue # Paylines typically don't start with scatter or empty positions

            match_symbol_id = None
            consecutive_count = 0
            winning_symbol_positions = []

            # Handle if the line starts with a wild symbol
            if first_symbol_on_line == wild_symbol_id:
                # Wilds substitute for other symbols. Need to find the first non-wild to determine the matching symbol.
                # Then count initial wilds + subsequent matching symbols or wilds.
                temp_match_symbol_id = None
                wilds_at_start = 0
                for i in range(len(line_symbols_on_grid)):
                    s_id = line_symbols_on_grid[i]
                    if s_id == wild_symbol_id:
                        wilds_at_start += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    elif s_id != scatter_symbol_id : # Found the symbol to match
                        temp_match_symbol_id = s_id
                        consecutive_count = wilds_at_start + 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                        match_symbol_id = temp_match_symbol_id
                        break
                    else: # Scatter or None, breaks payline continuity for this potential match
                        break

                if match_symbol_id is None and wilds_at_start > 0: # Line is all wilds (or wilds then scatter/None)
                    # If game rules allow all-wild lines, determine payout for wild symbol itself
                    # Wild symbol must have its own entry in 'value_multipliers' in config
                    symbol_config = config_symbols_map.get(wild_symbol_id)
                    if symbol_config and symbol_config.get('value_multipliers'):
                        match_symbol_id = wild_symbol_id
                        consecutive_count = wilds_at_start
                    else: # Wilds don't form their own win, or line too short
                        continue
            else:
                # Line starts with a regular symbol
                match_symbol_id = first_symbol_on_line
                consecutive_count = 1
                winning_symbol_positions.append(actual_positions_on_line[0])

            # Continue counting from the position after initial sequence
            # If first symbol was wild and found a match, `consecutive_count` is already set.
            # `i` should start from `consecutive_count` index in `line_symbols_on_grid`.
            if match_symbol_id: # Proceed if a potential winning line is identified
                for i in range(consecutive_count, len(line_symbols_on_grid)):
                    current_symbol_on_grid = line_symbols_on_grid[i]
                    if current_symbol_on_grid == match_symbol_id or current_symbol_on_grid == wild_symbol_id:
                        consecutive_count += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    else:
                        break # Sequence broken

            # Get payout for the matched sequence
            # The minimum match count is implicitly handled by what's defined in value_multipliers (e.g. no "1" or "2")
            payout_multiplier = get_symbol_payout(match_symbol_id, consecutive_count, config_symbols_map, is_scatter=False)
            # print(f"DEBUG_TEST_HANDLER: Payline {payline_id}, Symbol {match_symbol_id}, Count {consecutive_count}, PayoutMultiplier {payout_multiplier}") # Debug

            if payout_multiplier > 0:
                # Line win = bet_per_line * symbol_multiplier
                # Ensure bet_per_line_sats is used here.
                line_win_sats = int(bet_per_line_sats * payout_multiplier)

                # Apply spin multiplier if any (e.g. from free spins bonus)
                # This is now handled outside, after all raw wins are calculated.
                # line_win_sats = int(line_win_sats * current_spin_multiplier)


                if line_win_sats > 0:
                    total_win_sats += line_win_sats
                    winning_lines_data.append({
                        "line_id": payline_id, # From payline config
                        "symbol_id": match_symbol_id, # The symbol that formed the win (not wild, unless wild itself pays)
                        "count": consecutive_count,
                        "positions": winning_symbol_positions, # List of [r,c] coordinates
                        "win_amount_sats": line_win_sats
                    })
                    for pos in winning_symbol_positions:
                        all_winning_symbol_coords.add(tuple(pos))

        # --- Scatter Wins ---
        # (This part remains largely the same but contributes to all_winning_symbol_coords)
        scatter_positions_on_grid = []
        scatter_count_on_grid = 0
        if scatter_symbol_id is not None: # Check if a scatter symbol is configured
            for r_idx, row in enumerate(grid):
                for c_idx, symbol_in_cell in enumerate(row):
                    if symbol_in_cell == scatter_symbol_id:
                        scatter_count_on_grid += 1
                        scatter_positions_on_grid.append([r_idx, c_idx])

        # Get scatter payout based on count
        # Scatter payouts are typically multiples of the *total bet*
        scatter_payout_multiplier = get_symbol_payout(scatter_symbol_id, scatter_count_on_grid, config_symbols_map, is_scatter=True)

        if scatter_payout_multiplier > 0:
            scatter_win_sats = int(total_bet_sats * scatter_payout_multiplier)
            # scatter_win_sats = int(scatter_win_sats * current_spin_multiplier) # Apply spin multiplier - also handled outside now

            if scatter_win_sats > 0:
                total_win_sats += scatter_win_sats
                winning_lines_data.append({
                    "line_id": "scatter", # Special identifier for scatter wins
                    "symbol_id": scatter_symbol_id,
                    "count": scatter_count_on_grid,
                    "positions": scatter_positions_on_grid,
                    "win_amount_sats": scatter_win_sats
                })
                for pos in scatter_positions_on_grid: # Add scatter symbol positions for removal
                    all_winning_symbol_coords.add(tuple(pos))

        # --- TODO: Implement "Match N" / Cluster Pays Logic ---
        # If cfg_min_symbols_to_match is not None:
        #   1. Count all symbol occurrences on the grid.
        #   2. For symbols meeting cfg_min_symbols_to_match:
        #      a. Find their positions.
        #      b. Calculate win based on cfg_payouts (needs a specific structure for this type of win).
        #      c. Add to total_win_sats, winning_lines_data, and all_winning_symbol_coords.
        # This section will be complex and require careful handling of payout definitions.
        # For now, this placeholder indicates where it would go.

        # --- "Match N" / Cluster Pays Logic ---
        # This logic assumes "anywhere on grid" for clusters, and wilds contribute to any cluster they can help form.
        if min_symbols_to_match is not None and min_symbols_to_match > 0:
            symbol_counts = {}
            symbol_positions_map = {} # Stores list of positions for each symbol_id (excluding wilds initially)

            # Count literal symbols and their positions (excluding wilds for base count)
            for r, row_data in enumerate(grid):
                for c, s_id_in_cell in enumerate(row_data):
                    if s_id_in_cell is None: continue

                    # For cluster base counts, we only consider non-wild, non-scatter symbols here.
                    # Wilds are counted separately and added to effective counts.
                    # Scatters are typically handled by their own independent payout logic.
                    if s_id_in_cell != wild_symbol_id and s_id_in_cell != scatter_symbol_id:
                        symbol_counts[s_id_in_cell] = symbol_counts.get(s_id_in_cell, 0) + 1
                        if s_id_in_cell not in symbol_positions_map:
                            symbol_positions_map[s_id_in_cell] = []
                        symbol_positions_map[s_id_in_cell].append([r, c])

            # Count total wilds on the grid and their positions
            num_wilds_on_grid = 0
            wild_positions_on_grid = []
            if wild_symbol_id is not None:
                for r_idx, row_data in enumerate(grid):
                    for c_idx, s_id_in_cell in enumerate(row_data):
                        if s_id_in_cell == wild_symbol_id:
                            num_wilds_on_grid += 1
                            wild_positions_on_grid.append([r_idx, c_idx])

            for symbol_id, literal_symbol_count in symbol_counts.items():
                # Wilds do not form their own cluster type; they assist other symbols.
                # Scatter symbols are handled by their dedicated scatter win logic, not cluster logic here.
                if symbol_id == wild_symbol_id or symbol_id == scatter_symbol_id: # Should already be excluded by map population
                    continue

                effective_count = literal_symbol_count + num_wilds_on_grid

                if effective_count >= min_symbols_to_match:
                    # This symbol forms a "match N" win with the help of wilds.
                    # `config_payouts` is a list of dicts. We need to find the relevant one.
                    # Example structure for a cluster payout entry in `config_payouts`:
                    # { "type": "cluster", "symbol_id": <ID>, "matches": <N>, "multiplier": <X_per_symbol_or_fixed> }
                    # Or payouts might be within the symbol definition in `config_symbols_map`
                    # e.g. config_symbols_map[symbol_id].get('cluster_payouts', {}).get(str(effective_count))

                    payout_value_for_cluster = 0
                    symbol_config_data = config_symbols_map.get(symbol_id, {})
                    cluster_payout_rules = symbol_config_data.get('cluster_payouts', {}) # e.g. {"8": 100, "9": 150}

                    if cluster_payout_rules:
                        # The key in cluster_payouts is the string representation of the effective_count.
                        payout_value_for_cluster = cluster_payout_rules.get(str(effective_count), 0.0)

                    # Attempt 2: Fallback or alternative - search generic `config_payouts` list
                    # This is less direct. The gameConfig structure needs to be clear.
                    # if not payout_value_for_cluster:
                    #     for payout_rule in config_payouts:
                    #         if payout_rule.get("type") == "cluster" and \
                    #            payout_rule.get("symbol_id") == symbol_id and \
                    #            payout_rule.get("matches") == count:
                    #             payout_value_for_cluster = payout_rule.get("multiplier", 0.0)
                    #             break

                    if payout_value_for_cluster > 0:
                        # Cluster win amount calculation.
                        # Cluster win calculation: total_bet_sats * payout_value_for_cluster.
                        # This assumes the payout_value_for_cluster is a direct multiplier of the total bet for that cluster.
                        cluster_win_sats_this_group = int(total_bet_sats * payout_value_for_cluster)

                        if cluster_win_sats_this_group > 0:
>                           print(f"DEBUG: Cluster win for symbol {symbol_id} count {count} with multiplier {payout_value_for_cluster}. Win: {cluster_win_sats_this_group}")
E                           NameError: name 'count' is not defined

utils/spin_handler.py:782: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_cluster_win_one_wild_no_cascade>

    def test_cluster_win_one_wild_no_cascade(self):
        min_match = 5
        payouts_sym1 = {"5": 15.0} # 15x for 5 SymbolA
        self.helper_configure_cluster_game(min_match=min_match, cluster_payouts_sym1=payouts_sym1)

        # Grid: 4 SymbolA (id=1), 1 Wild (id=5)
        test_grid = [
            [1, 1, 2, 3, 2],
            [1, 1, 3, 2, 3],
            [5, 2, 3, 4, 3] # Wild at (2,0)
        ]
        self.mock_generate_grid.return_value = test_grid
        bet_amount = 100
        expected_win = 100 * 15.0 # 1500

>       result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

tests/test_spin_handler.py:539:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user = <[DetachedInstanceError('Instance <User at 0x7f202ebca5f0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202ebca5f0>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202ebc8b50> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202ebc8b50>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202ebca470> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202ebca470>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
            win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

            # Initial win calculation results
            initial_raw_win_sats = win_info['total_win_sats']
            winning_lines = win_info['winning_lines'] # From initial spin
            current_winning_coords = win_info['winning_symbol_coords'] # Coords from initial spin

            # Store initial grid for SlotSpin record
            initial_spin_grid_for_record = [row[:] for row in spin_result_grid] # Deep copy

            # Initialize total win & state for potential cascades
            total_win_for_entire_spin_sequence_raw = initial_raw_win_sats # Accumulates RAW wins (base + cascades without cascade multipliers)
                                                                    # This will then be multiplied by bonus_spin_multiplier if applicable.
                                                                    # OR, this accumulates wins *with* cascade multipliers, then gets *bonus_spin_multiplier*.
                                                                    # Let's use: sum of (raw_win * cascade_level_multiplier)

            # Let total_win_for_entire_spin_sequence represent the sum of:
            # (initial_raw_win) + (cascade1_raw_win * mult1) + (cascade2_raw_win * mult2) ...
            total_win_for_entire_spin_sequence = initial_raw_win_sats # Initial win has effective cascade multiplier of 1 or none.

            current_grid_state = spin_result_grid # This grid will be modified in cascades
            current_raw_win_for_cascade_loop = initial_raw_win_sats # Controls cascade loop continuation based on raw win of previous step

            max_cascade_multiplier_level_achieved = 0 # For SlotSpin.current_multiplier_level (tracks highest cfg_win_multipliers index used +1)
                                                 # Or simply the highest multiplier value achieved. Let's use the level for now.

            # --- Cascading Wins Logic ---
            if cfg_is_cascading and initial_raw_win_sats > 0 and current_winning_coords:
                cascade_level_counter = 0 # 0 means initial win, 1st cascade is level 1, etc.

                while current_raw_win_for_cascade_loop > 0 and current_winning_coords:
                    # 1. Grid Update: Remove winning symbols, fill new ones
                    current_grid_state = handle_cascade_fill(
                        current_grid_state,
                        current_winning_coords, # Coords from the previous win calculation
                        cfg_cascade_type,
                        slot.symbols, # db_symbols
                        cfg_symbols_map,
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id
                    )

                    # 2. Recalculate Wins on the new grid
                    cascade_win_info = calculate_win(
                        current_grid_state, # The newly formed grid
                        cfg_paylines,
                        cfg_symbols_map,
                        bet_amount_sats, # Base bet amount for calculating wins
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id,
                        # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                        cfg_min_symbols_to_match
                    )

                    new_raw_win_this_cascade = cascade_win_info['total_win_sats']
                    current_winning_coords = cascade_win_info['winning_symbol_coords'] # For the next iteration's fill

                    if new_raw_win_this_cascade > 0:
                        cascade_level_counter += 1 # This is the 1st, 2nd, etc. cascade event

                        current_cascade_multiplier = 1.0
                        if cfg_win_multipliers: # Check if win_multipliers are defined and non-empty
                            if cascade_level_counter -1 < len(cfg_win_multipliers): # cfg_win_multipliers is 0-indexed
                                current_cascade_multiplier = cfg_win_multipliers[cascade_level_counter -1]
                            elif cfg_win_multipliers: # Not empty, so use last available
                                current_cascade_multiplier = cfg_win_multipliers[-1]

                        if cascade_level_counter > max_cascade_multiplier_level_achieved: # Using counter as level proxy
                            max_cascade_multiplier_level_achieved = cascade_level_counter

                        # Add the (raw_win_from_this_cascade * its_cascade_multiplier) to the grand total
                        total_win_for_entire_spin_sequence += int(new_raw_win_this_cascade * current_cascade_multiplier)

                        current_raw_win_for_cascade_loop = new_raw_win_this_cascade # Keep loop going if there was a raw win

                        # Accumulate winning_lines (optional, can make response large)
                        # winning_lines.extend(cascade_win_info['winning_lines']) # Example if needed
                    else:
                        current_raw_win_for_cascade_loop = 0 # No new raw win, so stop cascading
                        current_winning_coords = [] # Clear coords
                # End of cascade loop

            # Now, total_win_for_entire_spin_sequence holds sum of (initial_raw + C1_raw*M1 + C2_raw*M2 ...)
            # Apply overall bonus spin multiplier if applicable (e.g., from free spins feature)
            final_win_amount_for_session_and_tx = total_win_for_entire_spin_sequence
            if is_bonus_spin and current_spin_multiplier > 1.0:
                final_win_amount_for_session_and_tx = int(total_win_for_entire_spin_sequence * current_spin_multiplier)
                # Note: if winning_lines are accumulated, their individual win_amount_sats would also need scaling
                # if a detailed breakdown of multiplied lines is required. Currently, `winning_lines` primarily reflects initial spin.

            # --- Check for Bonus Trigger (on non-bonus spins) ---
            # Bonus trigger check should be based on the *initial* spin grid results.
            bonus_triggered_this_spin = False
            newly_awarded_spins = 0
            new_bonus_multiplier = 1.0

            if not is_bonus_spin: # Bonus can only be triggered on a normal spin
                bonus_trigger_info = check_bonus_trigger(
                    initial_spin_grid_for_record, # Check on the initial grid
                    cfg_scatter_symbol_id,
                    cfg_bonus_features
                )
                if bonus_trigger_info['triggered']:
                    bonus_triggered_this_spin = True
                    newly_awarded_spins = bonus_trigger_info.get('spins_awarded', 0)
                    new_bonus_multiplier = bonus_trigger_info.get('multiplier', 1.0)


            # --- Update Session State for Bonus ---
            if bonus_triggered_this_spin:
                if not game_session.bonus_active: # Starting a new bonus
                    game_session.bonus_active = True
                    game_session.bonus_spins_remaining = newly_awarded_spins
                    game_session.bonus_multiplier = new_bonus_multiplier
                else: # Re-trigger or additional spins during an active bonus
                    game_session.bonus_spins_remaining += newly_awarded_spins
                    # Optionally, decide if multiplier updates or accumulates, based on game rules
                    # For now, assume it takes the new multiplier if retriggered, or keeps existing if just adding spins.
                    if new_bonus_multiplier != game_session.bonus_multiplier and newly_awarded_spins > 0 :
                         game_session.bonus_multiplier = new_bonus_multiplier # Or max(game_session.bonus_multiplier, new_bonus_multiplier)

            elif game_session.bonus_active and game_session.bonus_spins_remaining <= 0:
                # Bonus ended
                game_session.bonus_active = False
                game_session.bonus_multiplier = 1.0 # Reset multiplier


            # --- Update Session Aggregates ---
            game_session.num_spins += 1
            if not is_bonus_spin:
                game_session.amount_wagered = (game_session.amount_wagered or 0) + actual_bet_this_spin
            # `game_session.amount_won` is updated with the final win amount from this spin.
            # The previous logic added `win_amount_sats` (which was initial win pre-bonus mult).
            # We need to correct this if it was already added, or ensure it's added correctly once.
            # Assuming it was added: subtract old, add new.
            # If it wasn't added yet by this point, just add new.
            # The line `game_session.amount_won = (game_session.amount_won or 0) + win_amount_sats` was there.
            # So, we subtract that `win_amount_sats` (which is `initial_raw_win_sats` potentially multiplied by bonus_multiplier)
            # and add `final_win_amount_for_session_and_tx`.

            # Correction: The `win_amount_sats` that was added to `game_session.amount_won`
            # was the one *after* `if is_bonus_spin and current_spin_multiplier > 1.0:` block.
            # This means it was `initial_raw_win_sats * current_spin_multiplier` if bonus, else `initial_raw_win_sats`.
            # Let's denote this value as `previously_added_win_to_session`.
            previously_added_win_to_session = initial_raw_win_sats
            if is_bonus_spin and current_spin_multiplier > 1.0: # This replicates the original multiplication
                 previously_added_win_to_session = int(initial_raw_win_sats * current_spin_multiplier)

            game_session.amount_won = (game_session.amount_won or 0) - previously_added_win_to_session + final_win_amount_for_session_and_tx


            # --- Update User Balance & Win Transaction ---
            if final_win_amount_for_session_and_tx > 0:
                user.balance += final_win_amount_for_session_and_tx # Add final total win to user balance
                win_tx = Transaction(
                    user_id=user.id,
                    amount=final_win_amount_for_session_and_tx,
                    transaction_type='win',
                    details={
                        'slot_name': slot.name,
                        'session_id': game_session.id,
                        'is_cascade_win': cfg_is_cascading and max_cascade_multiplier_level_achieved > 0,
                        'initial_win': initial_raw_win_sats,
                        'total_cascade_win_multiplied': total_win_for_entire_spin_sequence - initial_raw_win_sats,
                        'bonus_spin_multiplier_applied': current_spin_multiplier if is_bonus_spin else 1.0
                        }
                        # game_session_id removed
                )
                db.session.add(win_tx)
                # game_session.transactions.append(win_tx) # If using relationship for this

            # --- Create Spin Record ---
            new_spin = SlotSpin(
                game_session_id=game_session.id,
                spin_result=initial_spin_grid_for_record, # Record the initial grid
                win_amount=final_win_amount_for_session_and_tx, # Total win from initial + all cascades (with all multipliers)
                bet_amount=actual_bet_this_spin,
                is_bonus_spin=is_bonus_spin,
                spin_time=datetime.now(timezone.utc),
                current_multiplier_level=max_cascade_multiplier_level_achieved # Store max cascade level reached
            )
            db.session.add(new_spin)
            # Crucially, flush here to get new_spin.id before assigning to transactions
            db.session.flush()

            # Link transactions to this spin
            if not is_bonus_spin and 'wager_tx' in locals() and wager_tx: # Ensure wager_tx exists
                wager_tx.slot_spin_id = new_spin.id
                wager_tx.details['slot_spin_id'] = new_spin.id
            if final_win_amount_for_session_and_tx > 0 and 'win_tx' in locals() and win_tx: # Ensure win_tx exists
                win_tx.slot_spin_id = new_spin.id
                win_tx.details['slot_spin_id'] = new_spin.id

            # --- Return Results ---
            # Ensure all satoshi amounts are integers
            return {
                "spin_result": initial_spin_grid_for_record, # Return the initial grid state
                "win_amount_sats": int(final_win_amount_for_session_and_tx),
                "winning_lines": winning_lines, # This currently holds results from the *initial* spin.
                                                # For a full breakdown, this would need to be an accumulation if cascades add more lines.
                "bonus_triggered": bonus_triggered_this_spin,
                "bonus_active": game_session.bonus_active,
                "bonus_spins_remaining": game_session.bonus_spins_remaining if game_session.bonus_active else 0,
                "bonus_multiplier": game_session.bonus_multiplier if game_session.bonus_active else 1.0,
                "user_balance_sats": int(user.balance),
                "session_stats": { # Consistent with other game types potentially
                    "num_spins": game_session.num_spins,
                    "amount_wagered_sats": int(game_session.amount_wagered or 0),
                    "amount_won_sats": int(game_session.amount_won or 0),
                }
            }
        except FileNotFoundError as e:
            # Log error appropriately
            # raise ValueError(f"Game configuration error: {e}") # Or handle more gracefully
            # For now, re-raise as ValueError for the route to catch
            # In a real app, you might want a more specific exception type.
            db.session.rollback() # Rollback any DB changes if config fails
            raise ValueError(str(e))
        except ValueError as e: # Catch specific errors like insufficient balance
            db.session.rollback()
            raise e # Re-raise it for the route to handle
        except Exception as e:
            db.session.rollback()
            # Log the exception e
            # Consider what to return or raise. A generic error for the user.
>           raise RuntimeError(f"An unexpected error occurred during the spin: {str(e)}") # Use str(e) for cleaner message
E           RuntimeError: An unexpected error occurred during the spin: name 'count' is not defined

utils/spin_handler.py:406: RuntimeError
_ TestSpinHandler.test_cluster_win_wilds_contribute_to_multiple_types_no_cascade _

user = <[DetachedInstanceError('Instance <User at 0x7f202ed0b040> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202ed0b040>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202ed086a0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202ed086a0>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202ed0b070> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202ed0b070>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
>           win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

utils/spin_handler.py:171:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

grid = [[1, 1, 1, 1, 2], [2, 2, 2, 2, 3], [5, 3, 3, 4, 3]], config_paylines = []
config_symbols_map = {1: {'asset': 'symA.png', 'cluster_payouts': {'5': 10.0}, 'id': 1, 'name': 'SymbolA', ...}, 2: {'asset': 'symB.png', '...bolC', 'weight': 30.0}, 4: {'asset': 'scatter.png', 'id': 4, 'name': 'Scatter', 'scatter_payouts': {'3': 5}, ...}, ...}
total_bet_sats = 100, wild_symbol_id = 5, scatter_symbol_id = 4
min_symbols_to_match = 5

    def calculate_win(grid, config_paylines, config_symbols_map, total_bet_sats, wild_symbol_id, scatter_symbol_id, min_symbols_to_match): # Removed current_spin_multiplier and general config_payouts
        """Calculates total win amount and identifies winning lines using config.
        `config_paylines` is game_config.game.layout.paylines
        `config_symbols_map` is game_config.game.symbols (mapped by id), used for symbol properties and payouts.
        `total_bet_sats` is the total amount bet for the entire spin.
        `wild_symbol_id` is the internal ID from config.
        `scatter_symbol_id` is the internal ID from config.
        `min_symbols_to_match` (from game_config.game.min_symbols_to_match) is for "Match N" or cluster logic.
        """
        # print(f"DEBUG_TEST_HANDLER: calculate_win called with total_bet_sats={total_bet_sats}") # Debug
        total_win_sats = 0
        winning_lines_data = [] # Store detailed info about each win
        all_winning_symbol_coords = set() # Using a set to store unique [r,c] tuples for removal
        num_rows = len(grid)
        num_cols = len(grid[0]) if num_rows > 0 else 0

        # --- Payline Wins ---
        # Bet per line calculation:
        num_active_paylines = len(config_paylines) # Assuming all defined paylines are played
        if num_active_paylines == 0:
            bet_per_line_sats = 0 # Avoid division by zero; though should not happen with valid config
        else:
            # Ensure integer division, handle potential rounding if necessary (though satoshis should be precise)
            bet_per_line_sats = total_bet_sats // num_active_paylines
            # It's possible that total_bet_sats is not perfectly divisible.
            # Game design should specify how this is handled (e.g. user bets per line, or total bet must be multiple of lines)
            # For now, we assume total_bet_sats is what's wagered, and bet_per_line is derived.
        # print(f"DEBUG_TEST_HANDLER: num_active_paylines={num_active_paylines}, bet_per_line_sats={bet_per_line_sats}") # Debug

        for payline_config in config_paylines:
            payline_id = payline_config.get("id", "unknown_line")
            payline_positions = payline_config.get("coords", []) # List of [row, col] #FIX: Changed "positions" to "coords"

            line_symbols_on_grid = [] # Actual symbol IDs on this payline from the spin grid
            actual_positions_on_line = [] # Coordinates of these symbols

            for r, c in payline_positions:
                if 0 <= r < num_rows and 0 <= c < num_cols:
                    symbol_on_grid = grid[r][c]
                    line_symbols_on_grid.append(symbol_on_grid)
                    actual_positions_on_line.append([r,c])
                else: # Should not happen with valid config
                    line_symbols_on_grid.append(None) # Placeholder for out-of-bounds
                    actual_positions_on_line.append(None)

            # Determine winning symbol and count for this line (left-to-right)
            first_symbol_on_line = line_symbols_on_grid[0]
            if first_symbol_on_line is None or first_symbol_on_line == scatter_symbol_id:
                continue # Paylines typically don't start with scatter or empty positions

            match_symbol_id = None
            consecutive_count = 0
            winning_symbol_positions = []

            # Handle if the line starts with a wild symbol
            if first_symbol_on_line == wild_symbol_id:
                # Wilds substitute for other symbols. Need to find the first non-wild to determine the matching symbol.
                # Then count initial wilds + subsequent matching symbols or wilds.
                temp_match_symbol_id = None
                wilds_at_start = 0
                for i in range(len(line_symbols_on_grid)):
                    s_id = line_symbols_on_grid[i]
                    if s_id == wild_symbol_id:
                        wilds_at_start += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    elif s_id != scatter_symbol_id : # Found the symbol to match
                        temp_match_symbol_id = s_id
                        consecutive_count = wilds_at_start + 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                        match_symbol_id = temp_match_symbol_id
                        break
                    else: # Scatter or None, breaks payline continuity for this potential match
                        break

                if match_symbol_id is None and wilds_at_start > 0: # Line is all wilds (or wilds then scatter/None)
                    # If game rules allow all-wild lines, determine payout for wild symbol itself
                    # Wild symbol must have its own entry in 'value_multipliers' in config
                    symbol_config = config_symbols_map.get(wild_symbol_id)
                    if symbol_config and symbol_config.get('value_multipliers'):
                        match_symbol_id = wild_symbol_id
                        consecutive_count = wilds_at_start
                    else: # Wilds don't form their own win, or line too short
                        continue
            else:
                # Line starts with a regular symbol
                match_symbol_id = first_symbol_on_line
                consecutive_count = 1
                winning_symbol_positions.append(actual_positions_on_line[0])

            # Continue counting from the position after initial sequence
            # If first symbol was wild and found a match, `consecutive_count` is already set.
            # `i` should start from `consecutive_count` index in `line_symbols_on_grid`.
            if match_symbol_id: # Proceed if a potential winning line is identified
                for i in range(consecutive_count, len(line_symbols_on_grid)):
                    current_symbol_on_grid = line_symbols_on_grid[i]
                    if current_symbol_on_grid == match_symbol_id or current_symbol_on_grid == wild_symbol_id:
                        consecutive_count += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    else:
                        break # Sequence broken

            # Get payout for the matched sequence
            # The minimum match count is implicitly handled by what's defined in value_multipliers (e.g. no "1" or "2")
            payout_multiplier = get_symbol_payout(match_symbol_id, consecutive_count, config_symbols_map, is_scatter=False)
            # print(f"DEBUG_TEST_HANDLER: Payline {payline_id}, Symbol {match_symbol_id}, Count {consecutive_count}, PayoutMultiplier {payout_multiplier}") # Debug

            if payout_multiplier > 0:
                # Line win = bet_per_line * symbol_multiplier
                # Ensure bet_per_line_sats is used here.
                line_win_sats = int(bet_per_line_sats * payout_multiplier)

                # Apply spin multiplier if any (e.g. from free spins bonus)
                # This is now handled outside, after all raw wins are calculated.
                # line_win_sats = int(line_win_sats * current_spin_multiplier)


                if line_win_sats > 0:
                    total_win_sats += line_win_sats
                    winning_lines_data.append({
                        "line_id": payline_id, # From payline config
                        "symbol_id": match_symbol_id, # The symbol that formed the win (not wild, unless wild itself pays)
                        "count": consecutive_count,
                        "positions": winning_symbol_positions, # List of [r,c] coordinates
                        "win_amount_sats": line_win_sats
                    })
                    for pos in winning_symbol_positions:
                        all_winning_symbol_coords.add(tuple(pos))

        # --- Scatter Wins ---
        # (This part remains largely the same but contributes to all_winning_symbol_coords)
        scatter_positions_on_grid = []
        scatter_count_on_grid = 0
        if scatter_symbol_id is not None: # Check if a scatter symbol is configured
            for r_idx, row in enumerate(grid):
                for c_idx, symbol_in_cell in enumerate(row):
                    if symbol_in_cell == scatter_symbol_id:
                        scatter_count_on_grid += 1
                        scatter_positions_on_grid.append([r_idx, c_idx])

        # Get scatter payout based on count
        # Scatter payouts are typically multiples of the *total bet*
        scatter_payout_multiplier = get_symbol_payout(scatter_symbol_id, scatter_count_on_grid, config_symbols_map, is_scatter=True)

        if scatter_payout_multiplier > 0:
            scatter_win_sats = int(total_bet_sats * scatter_payout_multiplier)
            # scatter_win_sats = int(scatter_win_sats * current_spin_multiplier) # Apply spin multiplier - also handled outside now

            if scatter_win_sats > 0:
                total_win_sats += scatter_win_sats
                winning_lines_data.append({
                    "line_id": "scatter", # Special identifier for scatter wins
                    "symbol_id": scatter_symbol_id,
                    "count": scatter_count_on_grid,
                    "positions": scatter_positions_on_grid,
                    "win_amount_sats": scatter_win_sats
                })
                for pos in scatter_positions_on_grid: # Add scatter symbol positions for removal
                    all_winning_symbol_coords.add(tuple(pos))

        # --- TODO: Implement "Match N" / Cluster Pays Logic ---
        # If cfg_min_symbols_to_match is not None:
        #   1. Count all symbol occurrences on the grid.
        #   2. For symbols meeting cfg_min_symbols_to_match:
        #      a. Find their positions.
        #      b. Calculate win based on cfg_payouts (needs a specific structure for this type of win).
        #      c. Add to total_win_sats, winning_lines_data, and all_winning_symbol_coords.
        # This section will be complex and require careful handling of payout definitions.
        # For now, this placeholder indicates where it would go.

        # --- "Match N" / Cluster Pays Logic ---
        # This logic assumes "anywhere on grid" for clusters, and wilds contribute to any cluster they can help form.
        if min_symbols_to_match is not None and min_symbols_to_match > 0:
            symbol_counts = {}
            symbol_positions_map = {} # Stores list of positions for each symbol_id (excluding wilds initially)

            # Count literal symbols and their positions (excluding wilds for base count)
            for r, row_data in enumerate(grid):
                for c, s_id_in_cell in enumerate(row_data):
                    if s_id_in_cell is None: continue

                    # For cluster base counts, we only consider non-wild, non-scatter symbols here.
                    # Wilds are counted separately and added to effective counts.
                    # Scatters are typically handled by their own independent payout logic.
                    if s_id_in_cell != wild_symbol_id and s_id_in_cell != scatter_symbol_id:
                        symbol_counts[s_id_in_cell] = symbol_counts.get(s_id_in_cell, 0) + 1
                        if s_id_in_cell not in symbol_positions_map:
                            symbol_positions_map[s_id_in_cell] = []
                        symbol_positions_map[s_id_in_cell].append([r, c])

            # Count total wilds on the grid and their positions
            num_wilds_on_grid = 0
            wild_positions_on_grid = []
            if wild_symbol_id is not None:
                for r_idx, row_data in enumerate(grid):
                    for c_idx, s_id_in_cell in enumerate(row_data):
                        if s_id_in_cell == wild_symbol_id:
                            num_wilds_on_grid += 1
                            wild_positions_on_grid.append([r_idx, c_idx])

            for symbol_id, literal_symbol_count in symbol_counts.items():
                # Wilds do not form their own cluster type; they assist other symbols.
                # Scatter symbols are handled by their dedicated scatter win logic, not cluster logic here.
                if symbol_id == wild_symbol_id or symbol_id == scatter_symbol_id: # Should already be excluded by map population
                    continue

                effective_count = literal_symbol_count + num_wilds_on_grid

                if effective_count >= min_symbols_to_match:
                    # This symbol forms a "match N" win with the help of wilds.
                    # `config_payouts` is a list of dicts. We need to find the relevant one.
                    # Example structure for a cluster payout entry in `config_payouts`:
                    # { "type": "cluster", "symbol_id": <ID>, "matches": <N>, "multiplier": <X_per_symbol_or_fixed> }
                    # Or payouts might be within the symbol definition in `config_symbols_map`
                    # e.g. config_symbols_map[symbol_id].get('cluster_payouts', {}).get(str(effective_count))

                    payout_value_for_cluster = 0
                    symbol_config_data = config_symbols_map.get(symbol_id, {})
                    cluster_payout_rules = symbol_config_data.get('cluster_payouts', {}) # e.g. {"8": 100, "9": 150}

                    if cluster_payout_rules:
                        # The key in cluster_payouts is the string representation of the effective_count.
                        payout_value_for_cluster = cluster_payout_rules.get(str(effective_count), 0.0)

                    # Attempt 2: Fallback or alternative - search generic `config_payouts` list
                    # This is less direct. The gameConfig structure needs to be clear.
                    # if not payout_value_for_cluster:
                    #     for payout_rule in config_payouts:
                    #         if payout_rule.get("type") == "cluster" and \
                    #            payout_rule.get("symbol_id") == symbol_id and \
                    #            payout_rule.get("matches") == count:
                    #             payout_value_for_cluster = payout_rule.get("multiplier", 0.0)
                    #             break

                    if payout_value_for_cluster > 0:
                        # Cluster win amount calculation.
                        # Cluster win calculation: total_bet_sats * payout_value_for_cluster.
                        # This assumes the payout_value_for_cluster is a direct multiplier of the total bet for that cluster.
                        cluster_win_sats_this_group = int(total_bet_sats * payout_value_for_cluster)

                        if cluster_win_sats_this_group > 0:
>                           print(f"DEBUG: Cluster win for symbol {symbol_id} count {count} with multiplier {payout_value_for_cluster}. Win: {cluster_win_sats_this_group}")
E                           NameError: name 'count' is not defined

utils/spin_handler.py:782: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_cluster_win_wilds_contribute_to_multiple_types_no_cascade>

    def test_cluster_win_wilds_contribute_to_multiple_types_no_cascade(self):
        min_match = 5
        payouts_sym1 = {"5": 10.0} # 10x for 5 SymbolA
        payouts_sym2 = {"5": 20.0} # 20x for 5 SymbolB
        self.helper_configure_cluster_game(min_match=min_match, cluster_payouts_sym1=payouts_sym1, cluster_payouts_sym2=payouts_sym2)

        # Grid: 4 SymbolA (id=1), 4 SymbolB (id=2), 1 Wild (id=5)
        test_grid = [
            [1, 1, 1, 1, 2],
            [2, 2, 2, 2, 3],
            [5, 3, 3, 4, 3] # Wild at (2,0)
        ]
        self.mock_generate_grid.return_value = test_grid
        bet_amount = 100
        expected_win_sym1 = 100 * 10.0 # 1000
        expected_win_sym2 = 100 * 20.0 # 2000
        expected_total_win = expected_win_sym1 + expected_win_sym2 # 3000

>       result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

tests/test_spin_handler.py:590:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user = <[DetachedInstanceError('Instance <User at 0x7f202ed0b040> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202ed0b040>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202ed086a0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202ed086a0>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202ed0b070> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202ed0b070>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
            win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

            # Initial win calculation results
            initial_raw_win_sats = win_info['total_win_sats']
            winning_lines = win_info['winning_lines'] # From initial spin
            current_winning_coords = win_info['winning_symbol_coords'] # Coords from initial spin

            # Store initial grid for SlotSpin record
            initial_spin_grid_for_record = [row[:] for row in spin_result_grid] # Deep copy

            # Initialize total win & state for potential cascades
            total_win_for_entire_spin_sequence_raw = initial_raw_win_sats # Accumulates RAW wins (base + cascades without cascade multipliers)
                                                                    # This will then be multiplied by bonus_spin_multiplier if applicable.
                                                                    # OR, this accumulates wins *with* cascade multipliers, then gets *bonus_spin_multiplier*.
                                                                    # Let's use: sum of (raw_win * cascade_level_multiplier)

            # Let total_win_for_entire_spin_sequence represent the sum of:
            # (initial_raw_win) + (cascade1_raw_win * mult1) + (cascade2_raw_win * mult2) ...
            total_win_for_entire_spin_sequence = initial_raw_win_sats # Initial win has effective cascade multiplier of 1 or none.

            current_grid_state = spin_result_grid # This grid will be modified in cascades
            current_raw_win_for_cascade_loop = initial_raw_win_sats # Controls cascade loop continuation based on raw win of previous step

            max_cascade_multiplier_level_achieved = 0 # For SlotSpin.current_multiplier_level (tracks highest cfg_win_multipliers index used +1)
                                                 # Or simply the highest multiplier value achieved. Let's use the level for now.

            # --- Cascading Wins Logic ---
            if cfg_is_cascading and initial_raw_win_sats > 0 and current_winning_coords:
                cascade_level_counter = 0 # 0 means initial win, 1st cascade is level 1, etc.

                while current_raw_win_for_cascade_loop > 0 and current_winning_coords:
                    # 1. Grid Update: Remove winning symbols, fill new ones
                    current_grid_state = handle_cascade_fill(
                        current_grid_state,
                        current_winning_coords, # Coords from the previous win calculation
                        cfg_cascade_type,
                        slot.symbols, # db_symbols
                        cfg_symbols_map,
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id
                    )

                    # 2. Recalculate Wins on the new grid
                    cascade_win_info = calculate_win(
                        current_grid_state, # The newly formed grid
                        cfg_paylines,
                        cfg_symbols_map,
                        bet_amount_sats, # Base bet amount for calculating wins
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id,
                        # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                        cfg_min_symbols_to_match
                    )

                    new_raw_win_this_cascade = cascade_win_info['total_win_sats']
                    current_winning_coords = cascade_win_info['winning_symbol_coords'] # For the next iteration's fill

                    if new_raw_win_this_cascade > 0:
                        cascade_level_counter += 1 # This is the 1st, 2nd, etc. cascade event

                        current_cascade_multiplier = 1.0
                        if cfg_win_multipliers: # Check if win_multipliers are defined and non-empty
                            if cascade_level_counter -1 < len(cfg_win_multipliers): # cfg_win_multipliers is 0-indexed
                                current_cascade_multiplier = cfg_win_multipliers[cascade_level_counter -1]
                            elif cfg_win_multipliers: # Not empty, so use last available
                                current_cascade_multiplier = cfg_win_multipliers[-1]

                        if cascade_level_counter > max_cascade_multiplier_level_achieved: # Using counter as level proxy
                            max_cascade_multiplier_level_achieved = cascade_level_counter

                        # Add the (raw_win_from_this_cascade * its_cascade_multiplier) to the grand total
                        total_win_for_entire_spin_sequence += int(new_raw_win_this_cascade * current_cascade_multiplier)

                        current_raw_win_for_cascade_loop = new_raw_win_this_cascade # Keep loop going if there was a raw win

                        # Accumulate winning_lines (optional, can make response large)
                        # winning_lines.extend(cascade_win_info['winning_lines']) # Example if needed
                    else:
                        current_raw_win_for_cascade_loop = 0 # No new raw win, so stop cascading
                        current_winning_coords = [] # Clear coords
                # End of cascade loop

            # Now, total_win_for_entire_spin_sequence holds sum of (initial_raw + C1_raw*M1 + C2_raw*M2 ...)
            # Apply overall bonus spin multiplier if applicable (e.g., from free spins feature)
            final_win_amount_for_session_and_tx = total_win_for_entire_spin_sequence
            if is_bonus_spin and current_spin_multiplier > 1.0:
                final_win_amount_for_session_and_tx = int(total_win_for_entire_spin_sequence * current_spin_multiplier)
                # Note: if winning_lines are accumulated, their individual win_amount_sats would also need scaling
                # if a detailed breakdown of multiplied lines is required. Currently, `winning_lines` primarily reflects initial spin.

            # --- Check for Bonus Trigger (on non-bonus spins) ---
            # Bonus trigger check should be based on the *initial* spin grid results.
            bonus_triggered_this_spin = False
            newly_awarded_spins = 0
            new_bonus_multiplier = 1.0

            if not is_bonus_spin: # Bonus can only be triggered on a normal spin
                bonus_trigger_info = check_bonus_trigger(
                    initial_spin_grid_for_record, # Check on the initial grid
                    cfg_scatter_symbol_id,
                    cfg_bonus_features
                )
                if bonus_trigger_info['triggered']:
                    bonus_triggered_this_spin = True
                    newly_awarded_spins = bonus_trigger_info.get('spins_awarded', 0)
                    new_bonus_multiplier = bonus_trigger_info.get('multiplier', 1.0)


            # --- Update Session State for Bonus ---
            if bonus_triggered_this_spin:
                if not game_session.bonus_active: # Starting a new bonus
                    game_session.bonus_active = True
                    game_session.bonus_spins_remaining = newly_awarded_spins
                    game_session.bonus_multiplier = new_bonus_multiplier
                else: # Re-trigger or additional spins during an active bonus
                    game_session.bonus_spins_remaining += newly_awarded_spins
                    # Optionally, decide if multiplier updates or accumulates, based on game rules
                    # For now, assume it takes the new multiplier if retriggered, or keeps existing if just adding spins.
                    if new_bonus_multiplier != game_session.bonus_multiplier and newly_awarded_spins > 0 :
                         game_session.bonus_multiplier = new_bonus_multiplier # Or max(game_session.bonus_multiplier, new_bonus_multiplier)

            elif game_session.bonus_active and game_session.bonus_spins_remaining <= 0:
                # Bonus ended
                game_session.bonus_active = False
                game_session.bonus_multiplier = 1.0 # Reset multiplier


            # --- Update Session Aggregates ---
            game_session.num_spins += 1
            if not is_bonus_spin:
                game_session.amount_wagered = (game_session.amount_wagered or 0) + actual_bet_this_spin
            # `game_session.amount_won` is updated with the final win amount from this spin.
            # The previous logic added `win_amount_sats` (which was initial win pre-bonus mult).
            # We need to correct this if it was already added, or ensure it's added correctly once.
            # Assuming it was added: subtract old, add new.
            # If it wasn't added yet by this point, just add new.
            # The line `game_session.amount_won = (game_session.amount_won or 0) + win_amount_sats` was there.
            # So, we subtract that `win_amount_sats` (which is `initial_raw_win_sats` potentially multiplied by bonus_multiplier)
            # and add `final_win_amount_for_session_and_tx`.

            # Correction: The `win_amount_sats` that was added to `game_session.amount_won`
            # was the one *after* `if is_bonus_spin and current_spin_multiplier > 1.0:` block.
            # This means it was `initial_raw_win_sats * current_spin_multiplier` if bonus, else `initial_raw_win_sats`.
            # Let's denote this value as `previously_added_win_to_session`.
            previously_added_win_to_session = initial_raw_win_sats
            if is_bonus_spin and current_spin_multiplier > 1.0: # This replicates the original multiplication
                 previously_added_win_to_session = int(initial_raw_win_sats * current_spin_multiplier)

            game_session.amount_won = (game_session.amount_won or 0) - previously_added_win_to_session + final_win_amount_for_session_and_tx


            # --- Update User Balance & Win Transaction ---
            if final_win_amount_for_session_and_tx > 0:
                user.balance += final_win_amount_for_session_and_tx # Add final total win to user balance
                win_tx = Transaction(
                    user_id=user.id,
                    amount=final_win_amount_for_session_and_tx,
                    transaction_type='win',
                    details={
                        'slot_name': slot.name,
                        'session_id': game_session.id,
                        'is_cascade_win': cfg_is_cascading and max_cascade_multiplier_level_achieved > 0,
                        'initial_win': initial_raw_win_sats,
                        'total_cascade_win_multiplied': total_win_for_entire_spin_sequence - initial_raw_win_sats,
                        'bonus_spin_multiplier_applied': current_spin_multiplier if is_bonus_spin else 1.0
                        }
                        # game_session_id removed
                )
                db.session.add(win_tx)
                # game_session.transactions.append(win_tx) # If using relationship for this

            # --- Create Spin Record ---
            new_spin = SlotSpin(
                game_session_id=game_session.id,
                spin_result=initial_spin_grid_for_record, # Record the initial grid
                win_amount=final_win_amount_for_session_and_tx, # Total win from initial + all cascades (with all multipliers)
                bet_amount=actual_bet_this_spin,
                is_bonus_spin=is_bonus_spin,
                spin_time=datetime.now(timezone.utc),
                current_multiplier_level=max_cascade_multiplier_level_achieved # Store max cascade level reached
            )
            db.session.add(new_spin)
            # Crucially, flush here to get new_spin.id before assigning to transactions
            db.session.flush()

            # Link transactions to this spin
            if not is_bonus_spin and 'wager_tx' in locals() and wager_tx: # Ensure wager_tx exists
                wager_tx.slot_spin_id = new_spin.id
                wager_tx.details['slot_spin_id'] = new_spin.id
            if final_win_amount_for_session_and_tx > 0 and 'win_tx' in locals() and win_tx: # Ensure win_tx exists
                win_tx.slot_spin_id = new_spin.id
                win_tx.details['slot_spin_id'] = new_spin.id

            # --- Return Results ---
            # Ensure all satoshi amounts are integers
            return {
                "spin_result": initial_spin_grid_for_record, # Return the initial grid state
                "win_amount_sats": int(final_win_amount_for_session_and_tx),
                "winning_lines": winning_lines, # This currently holds results from the *initial* spin.
                                                # For a full breakdown, this would need to be an accumulation if cascades add more lines.
                "bonus_triggered": bonus_triggered_this_spin,
                "bonus_active": game_session.bonus_active,
                "bonus_spins_remaining": game_session.bonus_spins_remaining if game_session.bonus_active else 0,
                "bonus_multiplier": game_session.bonus_multiplier if game_session.bonus_active else 1.0,
                "user_balance_sats": int(user.balance),
                "session_stats": { # Consistent with other game types potentially
                    "num_spins": game_session.num_spins,
                    "amount_wagered_sats": int(game_session.amount_wagered or 0),
                    "amount_won_sats": int(game_session.amount_won or 0),
                }
            }
        except FileNotFoundError as e:
            # Log error appropriately
            # raise ValueError(f"Game configuration error: {e}") # Or handle more gracefully
            # For now, re-raise as ValueError for the route to catch
            # In a real app, you might want a more specific exception type.
            db.session.rollback() # Rollback any DB changes if config fails
            raise ValueError(str(e))
        except ValueError as e: # Catch specific errors like insufficient balance
            db.session.rollback()
            raise e # Re-raise it for the route to handle
        except Exception as e:
            db.session.rollback()
            # Log the exception e
            # Consider what to return or raise. A generic error for the user.
>           raise RuntimeError(f"An unexpected error occurred during the spin: {str(e)}") # Use str(e) for cleaner message
E           RuntimeError: An unexpected error occurred during the spin: name 'count' is not defined

utils/spin_handler.py:406: RuntimeError
___________ TestSpinHandler.test_cluster_win_with_wilds_and_cascade ____________

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_cluster_win_with_wilds_and_cascade>

    def test_cluster_win_with_wilds_and_cascade(self):
        min_match = 4
        payouts_sym1 = {"4": 10.0} # 10x for 4 SymbolA
        self.helper_configure_cluster_game(min_match=min_match, cluster_payouts_sym1=payouts_sym1,
                                           is_cascading=True, cascade_type="fall_from_top", win_multipliers=[2.0])

        # Grid: 3 SymbolA (id=1), 1 Wild (id=5) at (0,0)
        # Winning symbols are (0,0)W, (0,1)A, (1,0)A, (1,1)A
        initial_grid = [
            [5, 1, 2, 3, 4], # Wild, SymbolA
            [1, 1, 3, 2, 3], # SymbolA, SymbolA
            [2, 3, 4, 5, 1]
        ]
        self.mock_generate_grid.return_value = initial_grid

        # Mock cascade fill: assume 4 new non-winning symbols (e.g., id 3)
        # This needs to provide enough side_effects for all symbols that are filled.
        # If 4 symbols are removed, and cascade is fall_from_top, it's complex.
        # Let's simplify: assume mock_choices is called once per empty cell to be filled from top.
        # (0,0), (0,1), (1,0), (1,1) are removed.
        # Col 0: (0,0) removed. (1,0) removed. (2,0) is 2.
        # After fall: grid[2,0] becomes 2. grid[1,0] needs fill. grid[0,0] needs fill.
        # Col 1: (0,1) removed. (1,1) removed. (2,1) is 3.
        # After fall: grid[2,1] becomes 3. grid[1,1] needs fill. grid[0,1] needs fill.
        # So, 4 fills are needed for the top two rows in cols 0 and 1.
        self.mock_choices.side_effect = [
            [[3]], [[3]], # For (0,0), (1,0)
            [[3]], [[3]]  # For (0,1), (1,1)
        ]

        bet_amount = 100
        initial_balance = self.user.balance
        expected_win_initial = 100 * 10.0 # 1000 (no cascade multiplier on initial win)
        # Assume no further wins from cascade for simplicity in this test.
        expected_total_win = expected_win_initial

        result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

>       self.assertEqual(result['win_amount_sats'], expected_total_win)
E       AssertionError: 0 != 1000.0

tests/test_spin_handler.py:662: AssertionError
___________ TestSpinHandler.test_match_n_cluster_wins_with_cascading ___________

user = <[DetachedInstanceError('Instance <User at 0x7f202efd35e0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202efd35e0>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202efd2a70> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202efd2a70>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202efd2b30> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202efd2b30>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
>           win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

utils/spin_handler.py:171:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

grid = [[1, 2, 3, 2], [1, 3, 2, 3], [3, 1, 1, 3]], config_paylines = []
config_symbols_map = {1: {'asset': 'cA.png', 'cluster_payouts': {'4': 10, '5': 20}, 'id': 1, 'name': 'ClusterSymA', ...}, 2: {'asset': 'cB....: {'4': 5}, 'id': 2, 'name': 'ClusterSymB', ...}, 3: {'asset': 'other.png', 'id': 3, 'name': 'OtherSym', 'weight': 30}}
total_bet_sats = 100, wild_symbol_id = 5, scatter_symbol_id = 4
min_symbols_to_match = 4

    def calculate_win(grid, config_paylines, config_symbols_map, total_bet_sats, wild_symbol_id, scatter_symbol_id, min_symbols_to_match): # Removed current_spin_multiplier and general config_payouts
        """Calculates total win amount and identifies winning lines using config.
        `config_paylines` is game_config.game.layout.paylines
        `config_symbols_map` is game_config.game.symbols (mapped by id), used for symbol properties and payouts.
        `total_bet_sats` is the total amount bet for the entire spin.
        `wild_symbol_id` is the internal ID from config.
        `scatter_symbol_id` is the internal ID from config.
        `min_symbols_to_match` (from game_config.game.min_symbols_to_match) is for "Match N" or cluster logic.
        """
        # print(f"DEBUG_TEST_HANDLER: calculate_win called with total_bet_sats={total_bet_sats}") # Debug
        total_win_sats = 0
        winning_lines_data = [] # Store detailed info about each win
        all_winning_symbol_coords = set() # Using a set to store unique [r,c] tuples for removal
        num_rows = len(grid)
        num_cols = len(grid[0]) if num_rows > 0 else 0

        # --- Payline Wins ---
        # Bet per line calculation:
        num_active_paylines = len(config_paylines) # Assuming all defined paylines are played
        if num_active_paylines == 0:
            bet_per_line_sats = 0 # Avoid division by zero; though should not happen with valid config
        else:
            # Ensure integer division, handle potential rounding if necessary (though satoshis should be precise)
            bet_per_line_sats = total_bet_sats // num_active_paylines
            # It's possible that total_bet_sats is not perfectly divisible.
            # Game design should specify how this is handled (e.g. user bets per line, or total bet must be multiple of lines)
            # For now, we assume total_bet_sats is what's wagered, and bet_per_line is derived.
        # print(f"DEBUG_TEST_HANDLER: num_active_paylines={num_active_paylines}, bet_per_line_sats={bet_per_line_sats}") # Debug

        for payline_config in config_paylines:
            payline_id = payline_config.get("id", "unknown_line")
            payline_positions = payline_config.get("coords", []) # List of [row, col] #FIX: Changed "positions" to "coords"

            line_symbols_on_grid = [] # Actual symbol IDs on this payline from the spin grid
            actual_positions_on_line = [] # Coordinates of these symbols

            for r, c in payline_positions:
                if 0 <= r < num_rows and 0 <= c < num_cols:
                    symbol_on_grid = grid[r][c]
                    line_symbols_on_grid.append(symbol_on_grid)
                    actual_positions_on_line.append([r,c])
                else: # Should not happen with valid config
                    line_symbols_on_grid.append(None) # Placeholder for out-of-bounds
                    actual_positions_on_line.append(None)

            # Determine winning symbol and count for this line (left-to-right)
            first_symbol_on_line = line_symbols_on_grid[0]
            if first_symbol_on_line is None or first_symbol_on_line == scatter_symbol_id:
                continue # Paylines typically don't start with scatter or empty positions

            match_symbol_id = None
            consecutive_count = 0
            winning_symbol_positions = []

            # Handle if the line starts with a wild symbol
            if first_symbol_on_line == wild_symbol_id:
                # Wilds substitute for other symbols. Need to find the first non-wild to determine the matching symbol.
                # Then count initial wilds + subsequent matching symbols or wilds.
                temp_match_symbol_id = None
                wilds_at_start = 0
                for i in range(len(line_symbols_on_grid)):
                    s_id = line_symbols_on_grid[i]
                    if s_id == wild_symbol_id:
                        wilds_at_start += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    elif s_id != scatter_symbol_id : # Found the symbol to match
                        temp_match_symbol_id = s_id
                        consecutive_count = wilds_at_start + 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                        match_symbol_id = temp_match_symbol_id
                        break
                    else: # Scatter or None, breaks payline continuity for this potential match
                        break

                if match_symbol_id is None and wilds_at_start > 0: # Line is all wilds (or wilds then scatter/None)
                    # If game rules allow all-wild lines, determine payout for wild symbol itself
                    # Wild symbol must have its own entry in 'value_multipliers' in config
                    symbol_config = config_symbols_map.get(wild_symbol_id)
                    if symbol_config and symbol_config.get('value_multipliers'):
                        match_symbol_id = wild_symbol_id
                        consecutive_count = wilds_at_start
                    else: # Wilds don't form their own win, or line too short
                        continue
            else:
                # Line starts with a regular symbol
                match_symbol_id = first_symbol_on_line
                consecutive_count = 1
                winning_symbol_positions.append(actual_positions_on_line[0])

            # Continue counting from the position after initial sequence
            # If first symbol was wild and found a match, `consecutive_count` is already set.
            # `i` should start from `consecutive_count` index in `line_symbols_on_grid`.
            if match_symbol_id: # Proceed if a potential winning line is identified
                for i in range(consecutive_count, len(line_symbols_on_grid)):
                    current_symbol_on_grid = line_symbols_on_grid[i]
                    if current_symbol_on_grid == match_symbol_id or current_symbol_on_grid == wild_symbol_id:
                        consecutive_count += 1
                        winning_symbol_positions.append(actual_positions_on_line[i])
                    else:
                        break # Sequence broken

            # Get payout for the matched sequence
            # The minimum match count is implicitly handled by what's defined in value_multipliers (e.g. no "1" or "2")
            payout_multiplier = get_symbol_payout(match_symbol_id, consecutive_count, config_symbols_map, is_scatter=False)
            # print(f"DEBUG_TEST_HANDLER: Payline {payline_id}, Symbol {match_symbol_id}, Count {consecutive_count}, PayoutMultiplier {payout_multiplier}") # Debug

            if payout_multiplier > 0:
                # Line win = bet_per_line * symbol_multiplier
                # Ensure bet_per_line_sats is used here.
                line_win_sats = int(bet_per_line_sats * payout_multiplier)

                # Apply spin multiplier if any (e.g. from free spins bonus)
                # This is now handled outside, after all raw wins are calculated.
                # line_win_sats = int(line_win_sats * current_spin_multiplier)


                if line_win_sats > 0:
                    total_win_sats += line_win_sats
                    winning_lines_data.append({
                        "line_id": payline_id, # From payline config
                        "symbol_id": match_symbol_id, # The symbol that formed the win (not wild, unless wild itself pays)
                        "count": consecutive_count,
                        "positions": winning_symbol_positions, # List of [r,c] coordinates
                        "win_amount_sats": line_win_sats
                    })
                    for pos in winning_symbol_positions:
                        all_winning_symbol_coords.add(tuple(pos))

        # --- Scatter Wins ---
        # (This part remains largely the same but contributes to all_winning_symbol_coords)
        scatter_positions_on_grid = []
        scatter_count_on_grid = 0
        if scatter_symbol_id is not None: # Check if a scatter symbol is configured
            for r_idx, row in enumerate(grid):
                for c_idx, symbol_in_cell in enumerate(row):
                    if symbol_in_cell == scatter_symbol_id:
                        scatter_count_on_grid += 1
                        scatter_positions_on_grid.append([r_idx, c_idx])

        # Get scatter payout based on count
        # Scatter payouts are typically multiples of the *total bet*
        scatter_payout_multiplier = get_symbol_payout(scatter_symbol_id, scatter_count_on_grid, config_symbols_map, is_scatter=True)

        if scatter_payout_multiplier > 0:
            scatter_win_sats = int(total_bet_sats * scatter_payout_multiplier)
            # scatter_win_sats = int(scatter_win_sats * current_spin_multiplier) # Apply spin multiplier - also handled outside now

            if scatter_win_sats > 0:
                total_win_sats += scatter_win_sats
                winning_lines_data.append({
                    "line_id": "scatter", # Special identifier for scatter wins
                    "symbol_id": scatter_symbol_id,
                    "count": scatter_count_on_grid,
                    "positions": scatter_positions_on_grid,
                    "win_amount_sats": scatter_win_sats
                })
                for pos in scatter_positions_on_grid: # Add scatter symbol positions for removal
                    all_winning_symbol_coords.add(tuple(pos))

        # --- TODO: Implement "Match N" / Cluster Pays Logic ---
        # If cfg_min_symbols_to_match is not None:
        #   1. Count all symbol occurrences on the grid.
        #   2. For symbols meeting cfg_min_symbols_to_match:
        #      a. Find their positions.
        #      b. Calculate win based on cfg_payouts (needs a specific structure for this type of win).
        #      c. Add to total_win_sats, winning_lines_data, and all_winning_symbol_coords.
        # This section will be complex and require careful handling of payout definitions.
        # For now, this placeholder indicates where it would go.

        # --- "Match N" / Cluster Pays Logic ---
        # This logic assumes "anywhere on grid" for clusters, and wilds contribute to any cluster they can help form.
        if min_symbols_to_match is not None and min_symbols_to_match > 0:
            symbol_counts = {}
            symbol_positions_map = {} # Stores list of positions for each symbol_id (excluding wilds initially)

            # Count literal symbols and their positions (excluding wilds for base count)
            for r, row_data in enumerate(grid):
                for c, s_id_in_cell in enumerate(row_data):
                    if s_id_in_cell is None: continue

                    # For cluster base counts, we only consider non-wild, non-scatter symbols here.
                    # Wilds are counted separately and added to effective counts.
                    # Scatters are typically handled by their own independent payout logic.
                    if s_id_in_cell != wild_symbol_id and s_id_in_cell != scatter_symbol_id:
                        symbol_counts[s_id_in_cell] = symbol_counts.get(s_id_in_cell, 0) + 1
                        if s_id_in_cell not in symbol_positions_map:
                            symbol_positions_map[s_id_in_cell] = []
                        symbol_positions_map[s_id_in_cell].append([r, c])

            # Count total wilds on the grid and their positions
            num_wilds_on_grid = 0
            wild_positions_on_grid = []
            if wild_symbol_id is not None:
                for r_idx, row_data in enumerate(grid):
                    for c_idx, s_id_in_cell in enumerate(row_data):
                        if s_id_in_cell == wild_symbol_id:
                            num_wilds_on_grid += 1
                            wild_positions_on_grid.append([r_idx, c_idx])

            for symbol_id, literal_symbol_count in symbol_counts.items():
                # Wilds do not form their own cluster type; they assist other symbols.
                # Scatter symbols are handled by their dedicated scatter win logic, not cluster logic here.
                if symbol_id == wild_symbol_id or symbol_id == scatter_symbol_id: # Should already be excluded by map population
                    continue

                effective_count = literal_symbol_count + num_wilds_on_grid

                if effective_count >= min_symbols_to_match:
                    # This symbol forms a "match N" win with the help of wilds.
                    # `config_payouts` is a list of dicts. We need to find the relevant one.
                    # Example structure for a cluster payout entry in `config_payouts`:
                    # { "type": "cluster", "symbol_id": <ID>, "matches": <N>, "multiplier": <X_per_symbol_or_fixed> }
                    # Or payouts might be within the symbol definition in `config_symbols_map`
                    # e.g. config_symbols_map[symbol_id].get('cluster_payouts', {}).get(str(effective_count))

                    payout_value_for_cluster = 0
                    symbol_config_data = config_symbols_map.get(symbol_id, {})
                    cluster_payout_rules = symbol_config_data.get('cluster_payouts', {}) # e.g. {"8": 100, "9": 150}

                    if cluster_payout_rules:
                        # The key in cluster_payouts is the string representation of the effective_count.
                        payout_value_for_cluster = cluster_payout_rules.get(str(effective_count), 0.0)

                    # Attempt 2: Fallback or alternative - search generic `config_payouts` list
                    # This is less direct. The gameConfig structure needs to be clear.
                    # if not payout_value_for_cluster:
                    #     for payout_rule in config_payouts:
                    #         if payout_rule.get("type") == "cluster" and \
                    #            payout_rule.get("symbol_id") == symbol_id and \
                    #            payout_rule.get("matches") == count:
                    #             payout_value_for_cluster = payout_rule.get("multiplier", 0.0)
                    #             break

                    if payout_value_for_cluster > 0:
                        # Cluster win amount calculation.
                        # Cluster win calculation: total_bet_sats * payout_value_for_cluster.
                        # This assumes the payout_value_for_cluster is a direct multiplier of the total bet for that cluster.
                        cluster_win_sats_this_group = int(total_bet_sats * payout_value_for_cluster)

                        if cluster_win_sats_this_group > 0:
>                           print(f"DEBUG: Cluster win for symbol {symbol_id} count {count} with multiplier {payout_value_for_cluster}. Win: {cluster_win_sats_this_group}")
E                           NameError: name 'count' is not defined

utils/spin_handler.py:782: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_match_n_cluster_wins_with_cascading>

    def test_match_n_cluster_wins_with_cascading(self):
        self.slot.is_cascading = True
        self.slot.cascade_type = "fall_from_top" # Or replace_in_place, choice affects fill mock
        self.slot.min_symbols_to_match = 4 # Example: needs 4 matching symbols for a cluster win
        self.slot.win_multipliers = "[2]" # Single cascade multiplier for simplicity

        test_config_cluster = {
            "game": {
                **BASE_GAME_CONFIG["game"],
                "is_cascading": True,
                "cascade_type": "fall_from_top",
                "win_multipliers": [2],
                "min_symbols_to_match": 4,
                "symbols": [
                    {"id": 1, "name": "ClusterSymA", "asset": "cA.png",
                     "cluster_payouts": {"4": 10, "5": 20}, "weight": 10}, # Pays 10x for 4 matches
                    {"id": 2, "name": "ClusterSymB", "asset": "cB.png",
                     "cluster_payouts": {"4": 5}, "weight": 20},
                    {"id": 3, "name": "OtherSym", "asset": "other.png", "weight": 30},
                ],
                "paylines": [] # Explicitly no paylines for this test, focus on cluster
            }
        }
        self.mock_load_config.return_value = test_config_cluster

        # Initial grid: 4x Symbol 1 (ClusterSymA)
        initial_grid_cluster = [
            [1, 2, 3, 2],
            [1, 1, 2, 3],
            [3, 3, 1, 1]  # Four 1s, scattered. calculate_win counts all.
        ]
        # This grid has five 1s. Let's adjust to exactly four for simpler first test.
        initial_grid_cluster = [
            [1, 2, 3, 2], # Row 0
            [1, 3, 2, 3], # Row 1
            [3, 1, 1, 3]  # Row 2. Total four 1s at (0,0), (1,0), (2,1), (2,2)
        ]
        self.mock_generate_grid.return_value = initial_grid_cluster

        # Symbols for cascade (fall_from_top):
        # The four '1's are removed. Their positions: (0,0), (1,0), (2,1), (2,2)
        # Column 0: grid[0,0] removed. Nothing above to fall. Needs 1 new symbol. Let it be 2.
        # Column 1: grid[2,1] removed. grid[1,1](3) falls to (2,1). grid[0,1](2) falls to (1,1). Needs 1 new at (0,1). Let it be 3.
        # Column 2: grid[2,2] removed. grid[1,2](2) falls to (2,2). grid[0,2](3) falls to (1,2). Needs 1 new at (0,2). Let it be 3.
        # This fill logic is complex to mock precisely without visualizing.
        # Let's simplify: assume 4 new symbols are needed and make them non-winning.
        self.mock_choices.side_effect = [
            [[2]], [[3]], [[3]], [[2]] # Fill the 4 emptied spots (or top spots) with non-winning sequence
        ]

        bet_amount = 100
        initial_balance = self.user.balance

        # Calculations:
        # Initial win: 4x Symbol 1 (ClusterSymA). Pays 10x for 4 matches (from cluster_payouts).
        #            Win = total_bet_sats * cluster_multiplier = 100 * 10 = 1000.
        # Cascade 1: Assume the fill [2,3,3,2] does not create a new cluster of >=4 identical symbols.
        #            No further wins.
        # Expected total win = 1000.
        expected_total_win = 1000
        expected_multiplier_level = 0 # No successful cascades that themselves won.

>       result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

tests/test_spin_handler.py:372:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user = <[DetachedInstanceError('Instance <User at 0x7f202efd35e0> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] User object at 0x7f202efd35e0>
slot = <[DetachedInstanceError('Instance <Slot at 0x7f202efd2a70> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] Slot object at 0x7f202efd2a70>
game_session = <[DetachedInstanceError('Instance <GameSession at 0x7f202efd2b30> is not bound to a Session; attribute refresh operation cannot proceed') raised in repr()] GameSession object at 0x7f202efd2b30>
bet_amount_sats = 100

    def handle_spin(user, slot, game_session, bet_amount_sats):
        """
        Handles the logic for a single slot machine spin.

        Args:
            user (User): The user performing the spin.
            slot (Slot): The slot machine being played.
            game_session (GameSession): The current active game session.
            bet_amount_sats (int): The amount bet in Satoshis.

        Returns:
            dict: A dictionary containing the results of the spin, structured as follows:
                {
                    "spin_result": list[list[int]],  # The grid of symbol IDs resulting from the spin.
                    "win_amount_sats": int,          # Total win amount in satoshis from this spin.
                    "winning_lines": list[dict],     # List of winning paylines and scatter wins. Each dict contains:
                                                     #   "line_id": str (e.g., "payline_1", "scatter"),
                                                     #   "symbol_id": int (winning symbol ID),
                                                     #   "count": int (number of matching symbols),
                                                     #   "positions": list[list[int]] (coordinates of winning symbols),
                                                     #   "win_amount_sats": int (win for this specific line/scatter)
                    "bonus_triggered": bool,         # True if a bonus feature was triggered on this spin.
                    "bonus_active": bool,            # True if a bonus (e.g., free spins) is currently active.
                    "bonus_spins_remaining": int,    # Number of free spins remaining if bonus_active.
                    "bonus_multiplier": float,       # Multiplier for wins during bonus spins if bonus_active.
                    "user_balance_sats": int,        # The user's balance after the spin.
                    "session_stats": dict            # Statistics for the current game session:
                                                     #   "num_spins": int,
                                                     #   "amount_wagered_sats": int,
                                                     #   "amount_won_sats": int
                }

        Side Effects:
            - Modifies the `user` object's balance.
            - Modifies the `game_session` object (e.g., `num_spins`, `amount_wagered`, `amount_won`, bonus states).
            - Creates `SlotSpin` record in the database for the current spin.
            - Creates `Transaction` records for wagers and wins.
            - Updates `UserBonus` wagering progress if an active bonus exists and the spin is a paid spin.
            - All database changes are added to the current `db.session` but NOT committed by this function.
              The caller is responsible for committing the session.

        Raises:
            FileNotFoundError: If the `gameConfig.json` for the slot is not found.
            ValueError: If the bet amount is invalid, user has insufficient balance for a paid spin,
                        or if there's a critical configuration error (e.g., no spinable symbols).
            RuntimeError: For other unexpected errors during spin processing.
        """
        try:
            # --- Load Game Configuration ---
            game_config = load_game_config(slot.short_name)

            # Extract key configurations
            cfg_layout = game_config.get('game', {}).get('layout', {})
            cfg_symbols_map = {s['id']: s for s in game_config.get('game', {}).get('symbols', [])}
            cfg_paylines = cfg_layout.get('paylines', [])
            cfg_rows = cfg_layout.get('rows', 3)
            cfg_columns = cfg_layout.get('columns', 5)
            cfg_wild_symbol_id = game_config.get('game', {}).get('wild_symbol_id')
            cfg_scatter_symbol_id = game_config.get('game', {}).get('scatter_symbol_id')
            cfg_bonus_features = game_config.get('game', {}).get('bonus_features', {})
            # New cascading configurations
            cfg_is_cascading = game_config.get('game', {}).get('is_cascading', False)
            cfg_cascade_type = game_config.get('game', {}).get('cascade_type', None) # e.g., "fall_from_top"
            cfg_min_symbols_to_match = game_config.get('game', {}).get('min_symbols_to_match', None) # For cluster/match-N
            cfg_win_multipliers = game_config.get('game', {}).get('win_multipliers', []) # For cascading wins e.g., [1,2,3,5]

            # --- Pre-Spin Validation ---
            if not isinstance(bet_amount_sats, int) or bet_amount_sats <= 0:
                raise ValueError("Invalid bet amount. Must be a positive integer (satoshis).")

            if user.balance < bet_amount_sats and not (game_session.bonus_active and game_session.bonus_spins_remaining > 0) :
                raise ValueError("Insufficient balance for this bet.")

            # --- Update Wagering Progress if Active Bonus (for PAID spins) ---
            actual_bet_this_spin_for_wagering = 0
            if not (game_session.bonus_active and game_session.bonus_spins_remaining > 0): # i.e., if this is a paid spin
                actual_bet_this_spin_for_wagering = bet_amount_sats

            if actual_bet_this_spin_for_wagering > 0:
                active_bonus = UserBonus.query.filter_by(
                    user_id=user.id,
                    is_active=True,
                    is_completed=False,
                    is_cancelled=False
                ).first()

                if active_bonus:
                    active_bonus.wagering_progress_sats += actual_bet_this_spin_for_wagering
                    active_bonus.updated_at = datetime.now(timezone.utc)

                    if active_bonus.wagering_progress_sats >= active_bonus.wagering_requirement_sats:
                        active_bonus.is_active = False
                        active_bonus.is_completed = True
                        active_bonus.completed_at = datetime.now(timezone.utc)
                        # print(f"User {user.id} completed wagering for UserBonus {active_bonus.id}.") # Logging handled by caller or removed for now

            # --- Determine Spin Type and Deduct Bet ---
            is_bonus_spin = False
            current_spin_multiplier = 1.0 # Multiplier for the current spin's winnings

            if game_session.bonus_active and game_session.bonus_spins_remaining > 0:
                is_bonus_spin = True
                current_spin_multiplier = game_session.bonus_multiplier # Use session's bonus multiplier
                game_session.bonus_spins_remaining -= 1
                # Bet is not deducted during a bonus spin
                actual_bet_this_spin = 0
            else:
                user.balance -= bet_amount_sats
                actual_bet_this_spin = bet_amount_sats
                # Create Wager Transaction
                wager_tx = Transaction(
                    user_id=user.id,
                    amount=-bet_amount_sats, # Negative for wager
                    transaction_type='wager', # Ensure this matches model's transaction_type column name
                    details={'slot_name': slot.name, 'session_id': game_session.id}, # Using details field
                    # description=f'Slot wager: {slot.name}', # Old description field
                        # game_session_id removed
                )
                db.session.add(wager_tx)
                # game_session.transactions.append(wager_tx) # Add to session if relationship is set up

            # --- Generate Spin Result ---
            # slot.symbols still provides the available symbols from DB.
            # We'll use cfg_symbols_map for properties like multipliers, is_wild, is_scatter
            # The generate_spin_grid function might need to be aware of symbol IDs from config
            cfg_reel_strips = game_config.get('game', {}).get('reel_strips') # Get reel_strips

            spin_result_grid = generate_spin_grid(
                cfg_rows,
                cfg_columns,
                slot.symbols, # List of SlotSymbol ORM objects
                cfg_wild_symbol_id, # Ensure this is cfg_wild_symbol_id from game_config.get('game',{}).get('symbol_wild')
                cfg_scatter_symbol_id, # Ensure this is cfg_scatter_symbol_id from game_config.get('game',{}).get('symbol_scatter')
                cfg_symbols_map, # Pass the config symbols map for weighting or other properties
                cfg_reel_strips # Pass the loaded reel_strips
            )

            # --- Calculate Wins ---
            # calculate_win will now use cfg_paylines and cfg_symbols_map
            win_info = calculate_win(
                spin_result_grid,
                cfg_paylines,
                cfg_symbols_map, # Use the symbol data from config
                bet_amount_sats, # This is the total bet for the spin
                cfg_wild_symbol_id,
                cfg_scatter_symbol_id,
                # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                cfg_min_symbols_to_match # Pass this to calculate_win for cluster/match-N logic
                # current_spin_multiplier is handled outside calculate_win now
            )

            # Initial win calculation results
            initial_raw_win_sats = win_info['total_win_sats']
            winning_lines = win_info['winning_lines'] # From initial spin
            current_winning_coords = win_info['winning_symbol_coords'] # Coords from initial spin

            # Store initial grid for SlotSpin record
            initial_spin_grid_for_record = [row[:] for row in spin_result_grid] # Deep copy

            # Initialize total win & state for potential cascades
            total_win_for_entire_spin_sequence_raw = initial_raw_win_sats # Accumulates RAW wins (base + cascades without cascade multipliers)
                                                                    # This will then be multiplied by bonus_spin_multiplier if applicable.
                                                                    # OR, this accumulates wins *with* cascade multipliers, then gets *bonus_spin_multiplier*.
                                                                    # Let's use: sum of (raw_win * cascade_level_multiplier)

            # Let total_win_for_entire_spin_sequence represent the sum of:
            # (initial_raw_win) + (cascade1_raw_win * mult1) + (cascade2_raw_win * mult2) ...
            total_win_for_entire_spin_sequence = initial_raw_win_sats # Initial win has effective cascade multiplier of 1 or none.

            current_grid_state = spin_result_grid # This grid will be modified in cascades
            current_raw_win_for_cascade_loop = initial_raw_win_sats # Controls cascade loop continuation based on raw win of previous step

            max_cascade_multiplier_level_achieved = 0 # For SlotSpin.current_multiplier_level (tracks highest cfg_win_multipliers index used +1)
                                                 # Or simply the highest multiplier value achieved. Let's use the level for now.

            # --- Cascading Wins Logic ---
            if cfg_is_cascading and initial_raw_win_sats > 0 and current_winning_coords:
                cascade_level_counter = 0 # 0 means initial win, 1st cascade is level 1, etc.

                while current_raw_win_for_cascade_loop > 0 and current_winning_coords:
                    # 1. Grid Update: Remove winning symbols, fill new ones
                    current_grid_state = handle_cascade_fill(
                        current_grid_state,
                        current_winning_coords, # Coords from the previous win calculation
                        cfg_cascade_type,
                        slot.symbols, # db_symbols
                        cfg_symbols_map,
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id
                    )

                    # 2. Recalculate Wins on the new grid
                    cascade_win_info = calculate_win(
                        current_grid_state, # The newly formed grid
                        cfg_paylines,
                        cfg_symbols_map,
                        bet_amount_sats, # Base bet amount for calculating wins
                        cfg_wild_symbol_id,
                        cfg_scatter_symbol_id,
                        # game_config.get('game', {}).get('payouts', []), # This general payouts list is no longer passed directly
                        cfg_min_symbols_to_match
                    )

                    new_raw_win_this_cascade = cascade_win_info['total_win_sats']
                    current_winning_coords = cascade_win_info['winning_symbol_coords'] # For the next iteration's fill

                    if new_raw_win_this_cascade > 0:
                        cascade_level_counter += 1 # This is the 1st, 2nd, etc. cascade event

                        current_cascade_multiplier = 1.0
                        if cfg_win_multipliers: # Check if win_multipliers are defined and non-empty
                            if cascade_level_counter -1 < len(cfg_win_multipliers): # cfg_win_multipliers is 0-indexed
                                current_cascade_multiplier = cfg_win_multipliers[cascade_level_counter -1]
                            elif cfg_win_multipliers: # Not empty, so use last available
                                current_cascade_multiplier = cfg_win_multipliers[-1]

                        if cascade_level_counter > max_cascade_multiplier_level_achieved: # Using counter as level proxy
                            max_cascade_multiplier_level_achieved = cascade_level_counter

                        # Add the (raw_win_from_this_cascade * its_cascade_multiplier) to the grand total
                        total_win_for_entire_spin_sequence += int(new_raw_win_this_cascade * current_cascade_multiplier)

                        current_raw_win_for_cascade_loop = new_raw_win_this_cascade # Keep loop going if there was a raw win

                        # Accumulate winning_lines (optional, can make response large)
                        # winning_lines.extend(cascade_win_info['winning_lines']) # Example if needed
                    else:
                        current_raw_win_for_cascade_loop = 0 # No new raw win, so stop cascading
                        current_winning_coords = [] # Clear coords
                # End of cascade loop

            # Now, total_win_for_entire_spin_sequence holds sum of (initial_raw + C1_raw*M1 + C2_raw*M2 ...)
            # Apply overall bonus spin multiplier if applicable (e.g., from free spins feature)
            final_win_amount_for_session_and_tx = total_win_for_entire_spin_sequence
            if is_bonus_spin and current_spin_multiplier > 1.0:
                final_win_amount_for_session_and_tx = int(total_win_for_entire_spin_sequence * current_spin_multiplier)
                # Note: if winning_lines are accumulated, their individual win_amount_sats would also need scaling
                # if a detailed breakdown of multiplied lines is required. Currently, `winning_lines` primarily reflects initial spin.

            # --- Check for Bonus Trigger (on non-bonus spins) ---
            # Bonus trigger check should be based on the *initial* spin grid results.
            bonus_triggered_this_spin = False
            newly_awarded_spins = 0
            new_bonus_multiplier = 1.0

            if not is_bonus_spin: # Bonus can only be triggered on a normal spin
                bonus_trigger_info = check_bonus_trigger(
                    initial_spin_grid_for_record, # Check on the initial grid
                    cfg_scatter_symbol_id,
                    cfg_bonus_features
                )
                if bonus_trigger_info['triggered']:
                    bonus_triggered_this_spin = True
                    newly_awarded_spins = bonus_trigger_info.get('spins_awarded', 0)
                    new_bonus_multiplier = bonus_trigger_info.get('multiplier', 1.0)


            # --- Update Session State for Bonus ---
            if bonus_triggered_this_spin:
                if not game_session.bonus_active: # Starting a new bonus
                    game_session.bonus_active = True
                    game_session.bonus_spins_remaining = newly_awarded_spins
                    game_session.bonus_multiplier = new_bonus_multiplier
                else: # Re-trigger or additional spins during an active bonus
                    game_session.bonus_spins_remaining += newly_awarded_spins
                    # Optionally, decide if multiplier updates or accumulates, based on game rules
                    # For now, assume it takes the new multiplier if retriggered, or keeps existing if just adding spins.
                    if new_bonus_multiplier != game_session.bonus_multiplier and newly_awarded_spins > 0 :
                         game_session.bonus_multiplier = new_bonus_multiplier # Or max(game_session.bonus_multiplier, new_bonus_multiplier)

            elif game_session.bonus_active and game_session.bonus_spins_remaining <= 0:
                # Bonus ended
                game_session.bonus_active = False
                game_session.bonus_multiplier = 1.0 # Reset multiplier


            # --- Update Session Aggregates ---
            game_session.num_spins += 1
            if not is_bonus_spin:
                game_session.amount_wagered = (game_session.amount_wagered or 0) + actual_bet_this_spin
            # `game_session.amount_won` is updated with the final win amount from this spin.
            # The previous logic added `win_amount_sats` (which was initial win pre-bonus mult).
            # We need to correct this if it was already added, or ensure it's added correctly once.
            # Assuming it was added: subtract old, add new.
            # If it wasn't added yet by this point, just add new.
            # The line `game_session.amount_won = (game_session.amount_won or 0) + win_amount_sats` was there.
            # So, we subtract that `win_amount_sats` (which is `initial_raw_win_sats` potentially multiplied by bonus_multiplier)
            # and add `final_win_amount_for_session_and_tx`.

            # Correction: The `win_amount_sats` that was added to `game_session.amount_won`
            # was the one *after* `if is_bonus_spin and current_spin_multiplier > 1.0:` block.
            # This means it was `initial_raw_win_sats * current_spin_multiplier` if bonus, else `initial_raw_win_sats`.
            # Let's denote this value as `previously_added_win_to_session`.
            previously_added_win_to_session = initial_raw_win_sats
            if is_bonus_spin and current_spin_multiplier > 1.0: # This replicates the original multiplication
                 previously_added_win_to_session = int(initial_raw_win_sats * current_spin_multiplier)

            game_session.amount_won = (game_session.amount_won or 0) - previously_added_win_to_session + final_win_amount_for_session_and_tx


            # --- Update User Balance & Win Transaction ---
            if final_win_amount_for_session_and_tx > 0:
                user.balance += final_win_amount_for_session_and_tx # Add final total win to user balance
                win_tx = Transaction(
                    user_id=user.id,
                    amount=final_win_amount_for_session_and_tx,
                    transaction_type='win',
                    details={
                        'slot_name': slot.name,
                        'session_id': game_session.id,
                        'is_cascade_win': cfg_is_cascading and max_cascade_multiplier_level_achieved > 0,
                        'initial_win': initial_raw_win_sats,
                        'total_cascade_win_multiplied': total_win_for_entire_spin_sequence - initial_raw_win_sats,
                        'bonus_spin_multiplier_applied': current_spin_multiplier if is_bonus_spin else 1.0
                        }
                        # game_session_id removed
                )
                db.session.add(win_tx)
                # game_session.transactions.append(win_tx) # If using relationship for this

            # --- Create Spin Record ---
            new_spin = SlotSpin(
                game_session_id=game_session.id,
                spin_result=initial_spin_grid_for_record, # Record the initial grid
                win_amount=final_win_amount_for_session_and_tx, # Total win from initial + all cascades (with all multipliers)
                bet_amount=actual_bet_this_spin,
                is_bonus_spin=is_bonus_spin,
                spin_time=datetime.now(timezone.utc),
                current_multiplier_level=max_cascade_multiplier_level_achieved # Store max cascade level reached
            )
            db.session.add(new_spin)
            # Crucially, flush here to get new_spin.id before assigning to transactions
            db.session.flush()

            # Link transactions to this spin
            if not is_bonus_spin and 'wager_tx' in locals() and wager_tx: # Ensure wager_tx exists
                wager_tx.slot_spin_id = new_spin.id
                wager_tx.details['slot_spin_id'] = new_spin.id
            if final_win_amount_for_session_and_tx > 0 and 'win_tx' in locals() and win_tx: # Ensure win_tx exists
                win_tx.slot_spin_id = new_spin.id
                win_tx.details['slot_spin_id'] = new_spin.id

            # --- Return Results ---
            # Ensure all satoshi amounts are integers
            return {
                "spin_result": initial_spin_grid_for_record, # Return the initial grid state
                "win_amount_sats": int(final_win_amount_for_session_and_tx),
                "winning_lines": winning_lines, # This currently holds results from the *initial* spin.
                                                # For a full breakdown, this would need to be an accumulation if cascades add more lines.
                "bonus_triggered": bonus_triggered_this_spin,
                "bonus_active": game_session.bonus_active,
                "bonus_spins_remaining": game_session.bonus_spins_remaining if game_session.bonus_active else 0,
                "bonus_multiplier": game_session.bonus_multiplier if game_session.bonus_active else 1.0,
                "user_balance_sats": int(user.balance),
                "session_stats": { # Consistent with other game types potentially
                    "num_spins": game_session.num_spins,
                    "amount_wagered_sats": int(game_session.amount_wagered or 0),
                    "amount_won_sats": int(game_session.amount_won or 0),
                }
            }
        except FileNotFoundError as e:
            # Log error appropriately
            # raise ValueError(f"Game configuration error: {e}") # Or handle more gracefully
            # For now, re-raise as ValueError for the route to catch
            # In a real app, you might want a more specific exception type.
            db.session.rollback() # Rollback any DB changes if config fails
            raise ValueError(str(e))
        except ValueError as e: # Catch specific errors like insufficient balance
            db.session.rollback()
            raise e # Re-raise it for the route to handle
        except Exception as e:
            db.session.rollback()
            # Log the exception e
            # Consider what to return or raise. A generic error for the user.
>           raise RuntimeError(f"An unexpected error occurred during the spin: {str(e)}") # Use str(e) for cleaner message
E           RuntimeError: An unexpected error occurred during the spin: name 'count' is not defined

utils/spin_handler.py:406: RuntimeError
_____________ TestSpinHandler.test_multiplier_progression_and_cap ______________

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_multiplier_progression_and_cap>

    def test_multiplier_progression_and_cap(self):
        self.slot.is_cascading = True
        self.slot.cascade_type = "replace_in_place"
        self.slot.win_multipliers = "[2, 3]" # Multipliers for 1st, 2nd+ cascade wins

        test_config_multi = {
            "game": {
                **BASE_GAME_CONFIG["game"],
                "is_cascading": True,
                "cascade_type": "replace_in_place",
                "win_multipliers": [2, 3], # Cap at 3x for 2nd cascade onwards
                "symbols": [
                    {"id": 1, "name": "SymbolA", "asset": "symA.png", "value_multipliers": {"3": 10}, "weight": 10},
                    {"id": 2, "name": "SymbolB", "asset": "symB.png", "value_multipliers": {"3": 5}, "weight": 20},
                    {"id": 3, "name": "SymbolC", "asset": "symC.png", "value_multipliers": {"3": 2}, "weight": 30}, # Non-winning
                ],
                "paylines": [{"id": "line_1", "positions": [[0,0],[0,1],[0,2]]}] # Top row payline
            }
        }
        self.mock_load_config.return_value = test_config_multi

        # Initial grid: 3xA (id=1) for a win
        initial_grid_multi = [
            [1, 1, 1, 2, 3], # Win: 3xA (id=1)
            [2, 3, 2, 3, 1],
            [3, 1, 3, 1, 2]
        ]
        self.mock_generate_grid.return_value = initial_grid_multi

        # Mock choices for cascades (replace_in_place at [0,0],[0,1],[0,2])
        self.mock_choices.side_effect = [
            # Cascade 1: Replace [1,1,1] with [2,2,2] (SymbolB) -> Wins
            [[2]], [[2]], [[2]],
            # Cascade 2: Replace [2,2,2] with [1,1,1] (SymbolA) -> Wins again
            [[1]], [[1]], [[1]],
            # Cascade 3: Replace [1,1,1] with [3,3,3] (SymbolC) -> No Win
            [[3]], [[3]], [[3]],
        ]

        bet_amount = 100
        initial_balance = self.user.balance

        # Calculations:
        # Initial win: 3x SymbolA (id=1). Pays 10x. Raw win = 100 * 10 = 1000.
        # Total = 1000.

        # Cascade 1: [2,2,2] (SymbolB) replaces initial [1,1,1]. SymbolB pays 5x.
        #            Raw win = 100 * 5 = 500.
        #            Multiplier for 1st cascade (level_counter=1) is win_multipliers[0]=2.
        #            Actual win from 1st cascade = 500 * 2 = 1000.
        # Total = 1000 + 1000 = 2000.
        # max_multiplier_level_achieved = 1 (as cascade_level_counter = 1)

        # Cascade 2: [1,1,1] (SymbolA) replaces [2,2,2]. SymbolA pays 10x.
        #            Raw win = 100 * 10 = 1000.
        #            Multiplier for 2nd cascade (level_counter=2) is win_multipliers[1]=3.
        #            Actual win from 2nd cascade = 1000 * 3 = 3000.
        # Total = 2000 + 3000 = 5000.
        # max_multiplier_level_achieved = 2 (as cascade_level_counter = 2)

        # Cascade 3: [3,3,3] (SymbolC) replaces [1,1,1]. No win. Loop terminates.
        #            cascade_level_counter would have been 3, but this cascade does not win.

        expected_total_win = 5000
        expected_multiplier_level = 2 # Highest cascade_level_counter that resulted in a win.

        result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

>       self.assertEqual(result['win_amount_sats'], expected_total_win)
E       AssertionError: 0 != 5000

tests/test_spin_handler.py:455: AssertionError
________________ TestSpinHandler.test_win_on_non_cascading_slot ________________

self = <tests.test_spin_handler.TestSpinHandler testMethod=test_win_on_non_cascading_slot>

    def test_win_on_non_cascading_slot(self):
        # Configure a winning grid
        winning_grid = [
            [1, 1, 1, 2, 3], # Symbol 1 (value 10 for 3) on payline
            [2, 3, 1, 2, 3],
            [3, 1, 2, 3, 1]
        ]
        self.mock_generate_grid.return_value = winning_grid
        self.slot.is_cascading = False # Ensure slot model reflects this

        # Ensure BASE_GAME_CONFIG reflects non-cascading for this test
        current_config = {**BASE_GAME_CONFIG,
            "game": {**BASE_GAME_CONFIG["game"], "is_cascading": False}
        }
        self.mock_load_config.return_value = current_config

        bet_amount = 100 # Assume 1 payline, so bet_per_line is 100
        initial_balance = self.user.balance

        # Symbol 1 pays 10x for 3 matches.
        # Expected win = bet_per_line * multiplier = 100 * 10 = 1000
        expected_win = 1000

        result = handle_spin(self.user, self.slot, self.game_session, bet_amount)

>       self.assertEqual(result['win_amount_sats'], expected_win)
E       AssertionError: 0 != 1000

tests/test_spin_handler.py:148: AssertionError
_______________ TestSpinHandlerUtils.test_calculate_win_scatter ________________

self = <tests.test_utils.TestSpinHandlerUtils testMethod=test_calculate_win_scatter>

    def test_calculate_win_scatter(self):
        """
        Test calculate_win with a scatter win.
        """
        grid = [[7, 1, 2], [3, 7, 4], [5, 6, 7]]
        config_paylines = []

        scatter_symbol_id = 7
        config_symbols_map = {
            1: {"id": 1, "name": "Symbol1"},
            7: {"id": 7, "name": "Scatter", "payouts": {"3": 5.0}},
        }

        total_bet_sats = 50
        expected_scatter_multiplier = 5.0
        expected_total_win = total_bet_sats * expected_scatter_multiplier

>       result = calculate_win(
            grid=grid,
            config_paylines=config_paylines,
            config_symbols_map=config_symbols_map,
            total_bet_sats=total_bet_sats,
            wild_symbol_id=None,
            scatter_symbol_id=scatter_symbol_id
        )
E       TypeError: calculate_win() missing 1 required positional argument: 'min_symbols_to_match'

tests/test_utils.py:76: TypeError
____________ TestSpinHandlerUtils.test_calculate_win_simple_payline ____________

self = <tests.test_utils.TestSpinHandlerUtils testMethod=test_calculate_win_simple_payline>

    def test_calculate_win_simple_payline(self):
        """
        Test calculate_win with a simple payline win.
        """
        grid = [[1, 1, 1, 2, 3], [4, 5, 6, 7, 8], [9, 10, 11, 12, 13]]
        config_paylines = [{"id": "line1", "positions": [[0, 0], [0, 1], [0, 2], [0,3], [0,4]]}] # Top row

        config_symbols_map = {
            1: {"id": 1, "name": "Symbol1", "value_multipliers": {"3": 10.0}},
            2: {"id": 2, "name": "Symbol2"},
            3: {"id": 3, "name": "Symbol3"},
        }

        total_bet_sats = 100
        expected_win_per_line = 10.0
        expected_total_win = 100 * expected_win_per_line

>       result = calculate_win(
            grid=grid,
            config_paylines=config_paylines,
            config_symbols_map=config_symbols_map,
            total_bet_sats=total_bet_sats,
            wild_symbol_id=None,
            scatter_symbol_id=None
        )
E       TypeError: calculate_win() missing 1 required positional argument: 'min_symbols_to_match'

tests/test_utils.py:43: TypeError
______________ TestBonusLogicUtils.test_update_wagering_progress _______________

self = <tests.test_utils.TestBonusLogicUtils testMethod=test_update_wagering_progress>

    def test_update_wagering_progress(self):
        # User created via BaseTestCase's _create_user helper
>       user = self._create_user(username="bonuswageruser", email="bwu@example.com", balance=5000)
E       TypeError: BaseTestCase._create_user() got an unexpected keyword argument 'balance'

tests/test_utils.py:167: TypeError
=============================== warnings summary ===============================
../venv/lib/python3.10/site-packages/pythonjsonlogger/jsonlogger.py:11
  /app/venv/lib/python3.10/site-packages/pythonjsonlogger/jsonlogger.py:11: DeprecationWarning: pythonjsonlogger.jsonlogger has been moved to pythonjsonlogger.json
    warnings.warn(

../venv/lib/python3.10/site-packages/marshmallow/__init__.py:17
  /app/venv/lib/python3.10/site-packages/marshmallow/__init__.py:17: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    __version_info__ = tuple(LooseVersion(__version__).version)

../venv/lib/python3.10/site-packages/marshmallow_sqlalchemy/convert.py:17
../venv/lib/python3.10/site-packages/marshmallow_sqlalchemy/convert.py:17
  /app/venv/lib/python3.10/site-packages/marshmallow_sqlalchemy/convert.py:17: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    _META_KWARGS_DEPRECATED = LooseVersion(ma.__version__) >= LooseVersion("3.10.0")

../venv/lib/python3.10/site-packages/marshmallow/fields.py:198
../venv/lib/python3.10/site-packages/marshmallow/fields.py:198
../venv/lib/python3.10/site-packages/marshmallow/fields.py:198
  /app/venv/lib/python3.10/site-packages/marshmallow/fields.py:198: RemovedInMarshmallow4Warning: Passing field metadata as a keyword arg is deprecated. Use the explicit `metadata=...` argument instead.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.10.17-final-0 _______________

Name                          Stmts   Miss  Cover
-------------------------------------------------
app.py                          108     20    81%
config.py                        22      3    86%
models.py                       410     17    96%
routes/__init__.py                0      0   100%
routes/admin.py                 250    210    16%
routes/auth.py                  109     50    54%
routes/baccarat.py              118     95    19%
routes/blackjack.py              62     47    24%
routes/meta_game.py              24     15    38%
routes/plinko.py                 65     53    18%
routes/poker.py                 163    136    17%
routes/roulette.py               60     47    22%
routes/slots.py                  98     81    17%
routes/spacecrash.py            155    131    15%
routes/user.py                   99     81    18%
schemas.py                      422     29    93%
services/__init__.py              0      0   100%
services/bonus_service.py        54     50     7%
utils/__init__.py                 0      0   100%
utils/baccarat_helper.py        155     43    72%
utils/bitcoin.py                 15      6    60%
utils/blackjack_helper.py       293    228    22%
utils/multiway_helper.py        245    232     5%
utils/plinko_helper.py           74     43    42%
utils/poker_helper.py           950    585    38%
utils/roulette_helper.py         51     41    20%
utils/slot_tester.py            423    263    38%
utils/spacecrash_handler.py      79     64    19%
utils/spin_handler.py           428    238    44%
-------------------------------------------------
TOTAL                          4932   2808    43%
Coverage HTML written to dir htmlcov
=========================== short test summary info ============================
FAILED tests/test_api.py::GameApiTests::test_spin_insufficient_balance - Asse...
FAILED tests/test_api.py::GameApiTests::test_spin_success - AssertionError: 4...
FAILED tests/test_api.py::BillingApiTests::test_deposit_fail_invalid_bonus_code
FAILED tests/test_api.py::BillingApiTests::test_deposit_success_no_bonus - As...
FAILED tests/test_api.py::BillingApiTests::test_deposit_success_with_valid_fixed_bonus
FAILED tests/test_api.py::BillingApiTests::test_deposit_success_with_valid_percentage_bonus
FAILED tests/test_api.py::BillingApiTests::test_withdraw_fail_active_bonus_wagering_incomplete
FAILED tests/test_api.py::BillingApiTests::test_withdraw_fail_insufficient_funds
FAILED tests/test_api.py::BillingApiTests::test_withdraw_success - AssertionE...
FAILED tests/test_api.py::PlinkoApiTests::test_plinko_play_insufficient_funds
FAILED tests/test_api.py::PlinkoApiTests::test_plinko_play_success - Assertio...
FAILED tests/test_api.py::PlinkoApiTests::test_plinko_play_validation_errors
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_get_baccarat_hand_admin_access
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_get_baccarat_hand_not_found
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_get_baccarat_hand_success
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_get_baccarat_hand_unauthorized
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_get_baccarat_tables
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_join_baccarat_table_not_active
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_join_baccarat_table_not_found
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_join_baccarat_table_success
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_play_baccarat_hand_insufficient_balance
FAILED tests/test_baccarat_api.py::TestBaccaratAPI::test_play_baccarat_hand_success_player_win
FAILED tests/test_baccarat_helper.py::TestBaccaratHelper::test_banker_stands_player_draws_third_card_8
FAILED tests/test_baccarat_helper.py::TestBaccaratHelper::test_banker_third_card_rules
FAILED tests/test_baccarat_helper.py::TestBaccaratHelper::test_play_baccarat_hand_natural_win
FAILED tests/test_multiway_helper.py::TestMultiwaySpinHandler::test_multiway_bonus_end_after_last_spin
FAILED tests/test_multiway_helper.py::TestMultiwaySpinHandler::test_multiway_bonus_spin_behavior_win_and_cost
FAILED tests/test_multiway_helper.py::TestMultiwaySpinHandler::test_multiway_free_spin_retrigger
FAILED tests/test_multiway_helper.py::TestMultiwaySpinHandler::test_multiway_free_spin_trigger
FAILED tests/test_poker_actions.py::TestHandleFold::test_handle_fold_success
FAILED tests/test_poker_actions.py::TestHandleBet::test_handle_bet_all_in - A...
FAILED tests/test_poker_actions.py::TestHandleBet::test_handle_bet_fail_outstanding_bet
FAILED tests/test_poker_actions.py::TestHandleBet::test_handle_bet_fail_validation
FAILED tests/test_poker_actions.py::TestHandleBet::test_handle_bet_success - ...
FAILED tests/test_poker_actions.py::TestHandleRaise::test_handle_raise_all_in_incomplete_raise
FAILED tests/test_poker_actions.py::TestHandleRaise::test_handle_raise_fail_no_prior_bet
FAILED tests/test_poker_actions.py::TestHandleRaise::test_handle_raise_fail_validation
FAILED tests/test_poker_actions.py::TestHandleRaise::test_handle_raise_success
FAILED tests/test_poker_pot_distribution.py::TestDistributePot::test_one_main_pot_one_side_pot
FAILED tests/test_poker_pot_distribution.py::TestDistributePot::test_single_winner_main_pot_no_rake_cap_hit
FAILED tests/test_poker_pot_distribution.py::TestDistributePot::test_split_pot_two_winners_main_pot
FAILED tests/test_slot_tester.py::TestSlotTester::test_bonus_trigger_and_mechanics
FAILED tests/test_slot_tester.py::TestSlotTester::test_calculate_win_scatter
FAILED tests/test_slot_tester.py::TestSlotTester::test_calculate_win_simple_payline
FAILED tests/test_slot_tester.py::TestSlotTester::test_get_symbol_payout_direct
FAILED tests/test_slot_tester.py::TestSlotTester::test_reel_strip_generation_basic
FAILED tests/test_spin_handler.py::TestSpinHandler::test_basic_cascade_fall_from_top
FAILED tests/test_spin_handler.py::TestSpinHandler::test_basic_cascade_replace_in_place
FAILED tests/test_spin_handler.py::TestSpinHandler::test_cluster_win_multiple_wilds_no_cascade
FAILED tests/test_spin_handler.py::TestSpinHandler::test_cluster_win_no_wilds_no_cascade
FAILED tests/test_spin_handler.py::TestSpinHandler::test_cluster_win_one_wild_no_cascade
FAILED tests/test_spin_handler.py::TestSpinHandler::test_cluster_win_wilds_contribute_to_multiple_types_no_cascade
FAILED tests/test_spin_handler.py::TestSpinHandler::test_cluster_win_with_wilds_and_cascade
FAILED tests/test_spin_handler.py::TestSpinHandler::test_match_n_cluster_wins_with_cascading
FAILED tests/test_spin_handler.py::TestSpinHandler::test_multiplier_progression_and_cap
FAILED tests/test_spin_handler.py::TestSpinHandler::test_win_on_non_cascading_slot
FAILED tests/test_utils.py::TestSpinHandlerUtils::test_calculate_win_scatter
FAILED tests/test_utils.py::TestSpinHandlerUtils::test_calculate_win_simple_payline
FAILED tests/test_utils.py::TestBonusLogicUtils::test_update_wagering_progress
============ 59 failed, 66 passed, 1 skipped, 7 warnings in 10.54s =============
