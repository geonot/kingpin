# Autogenerated migration for new slot: Crystal Cascade
"""
Revision ID: 20250605005440crys
Revises: 'plinko'
Create Date: 2025-06-05T00:54:40.305547+00:00
"""
from alembic import op
import sqlalchemy as sa
import datetime # Required for datetime.fromisoformat in generated code

# Attempt to import PostgreSQL specific types, fallback to generic JSON
try:
    from sqlalchemy.dialects import postgresql
    JSONB_TYPE = postgresql.JSONB(astext_type=sa.Text()) # Ensure astext_type for compatibility
except ImportError:
    JSONB_TYPE = sa.JSON

# revision identifiers, used by Alembic.
revision = '20250605005440crys'
down_revision = 'plinko' # Uses repr to correctly format None or string
branch_labels = None
depends_on = None

def upgrade():
    # Define table structures for insertion (should mirror models.py)
    slot_table = sa.table('slot',
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.String(100)),
        sa.Column('description', sa.Text()),
        sa.Column('num_rows', sa.Integer()),
        sa.Column('num_columns', sa.Integer()),
        sa.Column('num_symbols', sa.Integer()),
        sa.Column('wild_symbol_id', sa.Integer()), # Internal symbol ID
        sa.Column('scatter_symbol_id', sa.Integer()), # Internal symbol ID
        sa.Column('bonus_type', sa.String(50)),
        sa.Column('bonus_subtype', sa.String(50)),
        sa.Column('bonus_multiplier', sa.Float()),
        sa.Column('bonus_spins_trigger_count', sa.Integer()),
        sa.Column('bonus_spins_awarded', sa.Integer()),
        sa.Column('short_name', sa.String(50)),
        sa.Column('asset_directory', sa.String(255)),
        sa.Column('rtp', sa.Float()),
        sa.Column('volatility', sa.String(20)),
        sa.Column('is_active', sa.Boolean()),
        sa.Column('is_multiway', sa.Boolean()),
        sa.Column('reel_configurations', JSONB_TYPE),
        sa.Column('is_cascading', sa.Boolean()),
        sa.Column('cascade_type', sa.String(50)),
        sa.Column('min_symbols_to_match', sa.Integer()),
        sa.Column('win_multipliers', JSONB_TYPE),
        sa.Column('created_at', sa.DateTime(timezone=True)) # Ensure timezone=True if model expects it
    )

    slot_symbol_table = sa.table('slot_symbol',
        sa.Column('id', sa.Integer()), # This is PK of slot_symbol, not used in bulk_insert if auto-gen
        sa.Column('slot_id', sa.Integer()),
        sa.Column('symbol_internal_id', sa.Integer()),
        sa.Column('name', sa.String(50)),
        sa.Column('img_link', sa.String(255)),
        sa.Column('value_multiplier', sa.Float()),
        sa.Column('data', JSONB_TYPE)
    )

    # Data for slot table (ensure it's a list of dicts)
    # The dict_to_py_string helper ensures datetime objects are correctly represented
    _slot_insert_data = [{'id': 101, 'name': 'Crystal Cascade', 'description': 'A fun slot game with a Crystal Cascade theme, created by SlotBuilder.', 'num_rows': 3, 'num_columns': 5, 'num_symbols': 11, 'wild_symbol_id': 11, 'scatter_symbol_id': 9, 'bonus_type': 'free_spins', 'bonus_subtype': 'Crystal Cascade', 'bonus_multiplier': 1.0, 'bonus_spins_trigger_count': 3, 'bonus_spins_awarded': 10, 'short_name': 'crystal_cascade', 'asset_directory': '/crystal_cascade/', 'rtp': 96.0, 'volatility': 'Medium', 'is_active': True, 'is_multiway': False, 'reel_configurations': None, 'is_cascading': True, 'cascade_type': 'fall_from_top', 'min_symbols_to_match': 8, 'win_multipliers': [1, 2, 4, 6, 8, 10, 15, 20], 'created_at': datetime.datetime.fromisoformat('2025-06-05T00:54:40.305439+00:00')}]

    # Data for slot_symbol table
    _symbols_insert_data_list = [{'slot_id': 101, 'symbol_internal_id': 1, 'name': 'Low Symbol 1', 'img_link': '/crystal_cascade/sprite_0.png', 'value_multiplier': 1.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 2, 'name': 'Low Symbol 2', 'img_link': '/crystal_cascade/sprite_1.png', 'value_multiplier': 1.5, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 3, 'name': 'Low Symbol 3', 'img_link': '/crystal_cascade/sprite_2.png', 'value_multiplier': 2.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 4, 'name': 'Mid Symbol 1', 'img_link': '/crystal_cascade/sprite_3.png', 'value_multiplier': 3.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 5, 'name': 'Mid Symbol 2', 'img_link': '/crystal_cascade/sprite_4.png', 'value_multiplier': 4.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 6, 'name': 'Mid Symbol 3', 'img_link': '/crystal_cascade/sprite_5.png', 'value_multiplier': 5.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 7, 'name': 'High Symbol 1', 'img_link': '/crystal_cascade/sprite_6.png', 'value_multiplier': 10.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 8, 'name': 'High Symbol 2', 'img_link': '/crystal_cascade/sprite_7.png', 'value_multiplier': 20.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 9, 'name': 'Scatter', 'img_link': '/crystal_cascade/sprite_8.png', 'value_multiplier': 0.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 10, 'name': 'Bonus', 'img_link': '/crystal_cascade/sprite_9.png', 'value_multiplier': 0.0, 'data': {}},
        {'slot_id': 101, 'symbol_internal_id': 11, 'name': 'Wild', 'img_link': '/crystal_cascade/sprite_10.png', 'value_multiplier': 0.0, 'data': {}}]

    op.bulk_insert(slot_table, _slot_insert_data)
    op.bulk_insert(slot_symbol_table, _symbols_insert_data_list)

    print(f"Migration {revision}: Inserted slot 'Crystal Cascade' (DB ID: 101) and its {len(_symbols_insert_data_list)} symbols.")

def downgrade():
    # Use f-strings for slot_id, ensure it's an int for safety if used directly in SQL
    # For op.execute, parameters should ideally be bound, but simple f-string is used here.
    op.execute(f"DELETE FROM slot_symbol WHERE slot_id = {int(101)}")
    op.execute(f"DELETE FROM slot WHERE id = {int(101)}")
    print(f"Migration {revision}: Rolled back slot 'Crystal Cascade' (DB ID: 101) and its symbols.")
