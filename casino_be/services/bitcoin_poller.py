import os
import time
import requests
import logging
from dotenv import load_dotenv

# Load environment variables from .env file first
# This is important so that create_app() sees the DB URI if poller is run standalone
load_dotenv(os.path.join(os.path.dirname(__file__), '..', '.env'))

from flask import current_app # To be used within app_context
from app import create_app, db # Adjusted to import db directly if it's initialized in app.py
from models import User, Transaction # Assuming Transaction model is appropriately defined
from utils.bitcoin import get_address_from_private_key_wif, send_to_hot_wallet
# generate_bitcoin_wallet is not directly used by poller's core loop

# --- Configuration ---
# These are loaded from .env by load_dotenv() above.
# Default values are provided as fallbacks if not set in .env
DATABASE_URL = os.getenv('DATABASE_URL') # Already used by Flask app through Config
HOT_WALLET_ADDRESS = os.getenv('HOT_WALLET_ADDRESS', 'your_testnet_hot_wallet_address_here')
POLLING_INTERVAL_SECONDS = int(os.getenv('POLLING_INTERVAL_SECONDS', 60))
MIN_CONFIRMATIONS = int(os.getenv('MIN_CONFIRMATIONS', 1))
SERVICE_API_TOKEN = os.getenv('SERVICE_API_TOKEN') # Loaded from .env
INTERNAL_API_ENDPOINT_UPDATE_BALANCE = os.getenv('INTERNAL_API_ENDPOINT_UPDATE_BALANCE', "http://localhost:5000/api/internal/update_player_balance")
BLOCKCHAIN_EXPLORER_API_BASE_URL = os.getenv('BLOCKCHAIN_EXPLORER_API_URL', "https://blockstream.info/testnet/api") # e.g. https://blockstream.info/api or /testnet/api
NETWORK = os.getenv('NETWORK', 'testnet')

# --- Logging Setup ---
# Get FLASK_ENV, default to 'development' if not set
FLASK_ENV = os.getenv('FLASK_ENV', 'development')
POLLER_LOG_FILE = os.getenv('POLLER_LOG_FILE', '/var/log/casino_be_poller.log')

log_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Configure StreamHandler (console output)
stream_handler = logging.StreamHandler()
stream_handler.setFormatter(log_formatter)
logger.addHandler(stream_handler)

# Configure FileHandler for production
if FLASK_ENV == 'production':
    try:
        file_handler = logging.FileHandler(POLLER_LOG_FILE)
        file_handler.setFormatter(log_formatter)
        logger.addHandler(file_handler)
        logger.info(f"Production logging enabled. Log file: {POLLER_LOG_FILE}")
    except Exception as e:
        logger.error(f"Failed to configure FileHandler for production: {e}", exc_info=True)
        # Fallback to console logging only if file handler setup fails

# --- Globals ---
# In a production system, this should be persistent (e.g., Redis, database table)
# to survive poller restarts. For this exercise, it's in-memory.
PROCESSED_TX_IDS = set()

# --- Placeholder for secure private key retrieval ---
# This is a critical security point. In a real system, this would involve a secure vault.
# For this subtask, we'll simulate it.
# A known testnet address and its WIF for demonstration purposes.
# Replace with an actual Testnet address you control if you want to test end-to-end.
# Example: tb1qtestpollerdummyaddress (fictional)
# Corresponding WIF: cTestPollerDummyPrivateKeyWIF (fictional)
KNOWN_TESTNET_ADDRESS_FOR_POLLER_SIMULATION = "tb1qtestpollerdummyaddress" # This should be an address generated by your generate_bitcoin_wallet()
KNOWN_TESTNET_WIF_FOR_POLLER_SIMULATION = "cTestPollerDummyPrivateKeyWIF" # The WIF for the above address

def get_private_key_for_address(deposit_address: str) -> str | None:
    """
    Placeholder function to simulate private key retrieval.
    WARNING: This is NOT secure and is for demonstration ONLY.
    In a real system, private keys must be stored in a secure vault (e.g., HashiCorp Vault, HSM).
    """
    logger.info(f"Attempting to retrieve private key for address: {deposit_address}")
    # Simulate checking against a known test address for the poller demo
    if NETWORK == "testnet" and deposit_address == KNOWN_TESTNET_ADDRESS_FOR_POLLER_SIMULATION:
        logger.warning(
            f"SIMULATION: Returning known testnet WIF for address {deposit_address}. "
            "This is for poller flow demonstration ONLY."
        )
        return KNOWN_TESTNET_WIF_FOR_POLLER_SIMULATION

    # For other addresses, or if not on testnet with the specific demo address:
    logger.error(
        f"CRITICAL SECURITY SIMULATION: Private key for address {deposit_address} is not available "
        "through this placeholder function. A secure vault is needed in production."
    )
    # To allow the poller to proceed for other addresses (it will fail at sweep step):
    # return None
    # For testing the poller flow further, one might temporarily return a generic test WIF,
    # but this means any actual funds sent to other deposit addresses won't be sweepable by this simulation.
    # To make it fail clearly if a real address is encountered:
    if deposit_address != KNOWN_TESTNET_ADDRESS_FOR_POLLER_SIMULATION:
         logger.error(f"No WIF configured for {deposit_address} in this simulation.")
         return None
    return None # Default to None if no match


if __name__ == '__main__':
    logger.info("Bitcoin Polling Service starting...")
    logger.info(f"Configuration: Hot Wallet: {HOT_WALLET_ADDRESS}, Interval: {POLLING_INTERVAL_SECONDS}s, Min Confirmations: {MIN_CONFIRMATIONS}")
    logger.info(f"Network: {NETWORK}, Explorer API: {BLOCKCHAIN_EXPLORER_API_BASE_URL}")
    logger.info(f"Internal Balance Update API: {INTERNAL_API_ENDPOINT_UPDATE_BALANCE}")
    if not SERVICE_API_TOKEN:
        logger.error("CRITICAL: SERVICE_API_TOKEN is not set. The poller cannot update balances.")
        exit(1)
    if not DATABASE_URL:
        logger.error("CRITICAL: DATABASE_URL is not set. Cannot connect to the database.")
        # Flask app context below will also fail, but good to check early.
        exit(1)

    # The main loop will be added in the next step.
    # For now, this confirms config loading.
    logger.info("Poller initialized. Main loop will be implemented next.")

    # Example of how app context would be used (to be filled in later)
    # app = create_app()
    # with app.app_context():
    #     logger.info("Successfully created app context for poller.")
    #     # Test DB connection (optional)
    #     try:
    #         user_count = User.query.count()
    #         logger.info(f"Successfully connected to DB. User count: {user_count}")
    #     except Exception as e:
    #         logger.error(f"Failed to connect to DB within app context: {e}", exc_info=True)

# --- API Interaction Functions ---
def update_player_balance_api(user_id: int, amount_sats: int, original_tx_id: str):
    """
    Calls the internal API to update the player's balance.
    """
    if not SERVICE_API_TOKEN:
        logger.error("SERVICE_API_TOKEN is not configured. Cannot update balance via API.")
        return False

    headers = {
        'X-Service-Token': SERVICE_API_TOKEN,
        'Content-Type': 'application/json'
    }
    payload = {
        'user_id': user_id,
        'sats_amount': amount_sats,
        'original_tx_id': original_tx_id
    }
    try:
        response = requests.post(INTERNAL_API_ENDPOINT_UPDATE_BALANCE, json=payload, headers=headers, timeout=10)
        if response.status_code == 200:
            logger.info(f"Successfully updated balance for user {user_id} via API for tx {original_tx_id}. Amount: {amount_sats}")
            return True
        else:
            logger.error(
                f"Failed to update balance for user {user_id} via API for tx {original_tx_id}. "
                f"Status: {response.status_code}, Response: {response.text}"
            )
            return False
    except requests.RequestException as e:
        logger.error(f"API call to update balance failed for user {user_id}, tx {original_tx_id}: {e}", exc_info=True)
        return False

def check_address_for_transactions(deposit_address: str, user_id: int):
    """
    Checks a given deposit address for new transactions using a blockchain explorer API.
    Processes confirmed deposits by attempting to sweep to hot wallet and updating balance.
    """
    if not deposit_address:
        logger.warning(f"Skipping check for user {user_id} due to missing deposit address.")
        return

    explorer_url = f"{BLOCKCHAIN_EXPLORER_API_BASE_URL}/address/{deposit_address}/txs"
    logger.info(f"Checking for transactions for address: {deposit_address} (User ID: {user_id})")

    try:
        response = requests.get(explorer_url, timeout=20) # Increased timeout for explorer API
        response.raise_for_status()  # Raise HTTPError for bad responses (4XX or 5XX)
        transactions = response.json()
    except requests.RequestException as e:
        logger.error(f"Could not fetch transactions for {deposit_address}: {e}", exc_info=True)
        return
    except ValueError as e: # Includes JSONDecodeError
        logger.error(f"Could not decode JSON response for {deposit_address}: {e}. Response text: {response.text[:200]}")
        return


    if not transactions:
        logger.info(f"No transactions found for address: {deposit_address}")
        return

    logger.info(f"Found {len(transactions)} transactions for address {deposit_address}.")

    for tx in transactions:
        txid = tx.get('txid')
        if not txid:
            logger.warning(f"Found a transaction without a txid for address {deposit_address}. Skipping. TX: {tx}")
            continue

        if txid in PROCESSED_TX_IDS:
            logger.debug(f"Transaction {txid} already processed. Skipping.")
            continue

        # Check confirmations (structure depends on Blockstream API)
        # status = {'confirmed': True, 'block_height': 700000, 'block_hash': '...', 'block_time': ...}
        status = tx.get('status')
        if not status or not status.get('confirmed'):
            logger.info(f"Transaction {txid} for address {deposit_address} is not confirmed yet. Skipping.")
            continue

        # Simplified confirmation check (Blockstream API provides block_height)
        # For more robust confirmation counting, you'd need current block height.
        # Assuming if 'confirmed' is true and block_height exists, it meets MIN_CONFIRMATIONS for this example.
        # A real implementation would compare status.block_height with (current_block_height - MIN_CONFIRMATIONS + 1)
        if status.get('block_height') is None : # If confirmed but no block height, something is odd.
             logger.warning(f"Transaction {txid} is confirmed but has no block_height. Skipping for safety.")
             continue

        # Calculate amount sent to the deposit_address
        # This requires iterating through outputs (vout)
        amount_received_sats = 0
        for vout in tx.get('vout', []):
            if vout.get('scriptpubkey_address') == deposit_address:
                amount_received_sats += vout.get('value', 0)

        if amount_received_sats <= 0:
            logger.info(f"No amount found for deposit_address {deposit_address} in tx {txid}. Skipping.")
            continue

        logger.info(f"Confirmed transaction {txid} for address {deposit_address} with {amount_received_sats} sats.")

        private_key_wif = get_private_key_for_address(deposit_address)
        if not private_key_wif:
            logger.error(
                f"CRITICAL: Could not retrieve private key for address {deposit_address} (User ID: {user_id}) for tx {txid}. "
                "Cannot attempt sweep. Manual intervention likely required if this is not the KNOWN_TESTNET_ADDRESS."
            )
            # Depending on policy, you might add txid to PROCESSED_TX_IDS to avoid retrying a non-sweepable TX,
            # or leave it for manual check. For now, we skip adding to processed if sweep prep fails.
            continue

        # Simulate sweeping the entire received amount (minus a placeholder fee)
        # A real sweep needs to manage UTXOs for the deposit_address.
        # The `send_to_hot_wallet` in bitcoin.py is a placeholder.
        # For simplicity, assume fee is small or handled by send_to_hot_wallet.
        # The `amount_received_sats` is what we want to credit. The sweep function would handle the actual balance.

        # For simulation, we assume the sweep function will attempt to send `amount_received_sats`.
        # A more realistic sweep would get the total balance of `deposit_address` and send that.
        # Let's assume `send_to_hot_wallet` is smart enough to sweep the UTXO corresponding to `amount_received_sats`
        # or the entire balance of the address if that's how it's designed.
        # The placeholder `send_to_hot_wallet` just logs, so we pass `amount_received_sats`.

        # Placeholder fee for simulation. A real system calculates this based on tx size and fee rate.
        simulated_fee_sats = 1000

        sweep_txid = send_to_hot_wallet(
            private_key_wif=private_key_wif,
            amount_sats=amount_received_sats, # This is the amount to credit. The sweep should ideally take total balance.
            hot_wallet_address=HOT_WALLET_ADDRESS,
            fee_sats=simulated_fee_sats # Placeholder fee
        )

        if sweep_txid: # If simulated sweep is successful
            logger.info(f"Successfully simulated sweep of {amount_received_sats} sats from {deposit_address} to {HOT_WALLET_ADDRESS}. Sweep TXID: {sweep_txid}")
            if update_player_balance_api(user_id, amount_received_sats, txid):
                logger.info(f"Successfully processed deposit {txid} for user {user_id}, amount {amount_received_sats}.")
                PROCESSED_TX_IDS.add(txid)
            else:
                logger.error(
                    f"Failed to update balance via API for user {user_id} after successful sweep of tx {txid}. "
                    "This is a critical issue requiring manual reconciliation."
                )
                # Do NOT add to PROCESSED_TX_IDS if API update fails, so it can be retried.
        else:
            logger.error(
                f"Failed to simulate sweep for tx {txid} from address {deposit_address} (User ID: {user_id}). "
                "Deposit will not be credited automatically at this time."
            )
            # Do not add to PROCESSED_TX_IDS if sweep fails.

def poll_deposits():
    """
    Main polling function to check for new deposits.
    Runs within a Flask app context.
    """
    app = create_app()
    with app.app_context():
        logger.info("Polling for new Bitcoin deposits...")
        try:
            users_with_wallets = User.query.filter(User.deposit_wallet_address.isnot(None)).all()
            if not users_with_wallets:
                logger.info("No users with deposit wallets found to poll.")
                return

            logger.info(f"Found {len(users_with_wallets)} users with deposit wallets.")
            for user in users_with_wallets:
                if user.deposit_wallet_address: # Redundant check, but good practice
                    check_address_for_transactions(user.deposit_wallet_address, user.id)
                else:
                    logger.warning(f"User ID {user.id} listed with wallets but has no deposit_wallet_address. Skipping.")
        except Exception as e:
            logger.error(f"Error during polling cycle: {e}", exc_info=True)
        finally:
            # Explicitly close the database session if using SQLAlchemy session directly
            # For Flask-SQLAlchemy, db.session is typically managed per request or app context.
            # db.session.remove() # Or db.session.close() if appropriate
            logger.info("Polling cycle finished.")


if __name__ == '__main__':
    logger.info("Bitcoin Polling Service starting...")
    logger.info(f"Configuration: Hot Wallet: {HOT_WALLET_ADDRESS}, Interval: {POLLING_INTERVAL_SECONDS}s, Min Confirmations: {MIN_CONFIRMATIONS}")
    logger.info(f"Network: {NETWORK}, Explorer API: {BLOCKCHAIN_EXPLORER_API_BASE_URL}")
    logger.info(f"Internal Balance Update API: {INTERNAL_API_ENDPOINT_UPDATE_BALANCE}")

    if not SERVICE_API_TOKEN:
        logger.error("CRITICAL: SERVICE_API_TOKEN is not set. Poller cannot update balances.")
        exit(1)
    if not DATABASE_URL: # Check if DATABASE_URL (used by create_app for SQLALCHEMY_DATABASE_URI) is available
        logger.error("CRITICAL: DATABASE_URL is not set. Cannot connect to the database.")
        exit(1)
    if not HOT_WALLET_ADDRESS or "your_testnet_hot_wallet_address_here" in HOT_WALLET_ADDRESS :
        logger.warning("WARNING: HOT_WALLET_ADDRESS is not configured or is using a default placeholder.")
        # Allow to run for testing, but this would be an error in prod.

    logger.info("Poller initialized. Starting main loop...")
    while True:
        try:
            poll_deposits()
        except Exception as e:
            logger.error(f"Unhandled exception in main polling loop: {e}", exc_info=True)
            # Avoid rapid-fire restarts on persistent errors in the loop itself
            # (though poll_deposits has its own try/except)
        logger.info(f"Sleeping for {POLLING_INTERVAL_SECONDS} seconds...")
        time.sleep(POLLING_INTERVAL_SECONDS)
