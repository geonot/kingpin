import os
import time
import requests
import logging
import uuid # Added for cycle_id
from dotenv import load_dotenv
from pythonjsonlogger import jsonlogger # Added for JSON logging

# Load environment variables from .env file first
# This is important so that create_app() sees the DB URI if poller is run standalone
load_dotenv(os.path.join(os.path.dirname(__file__), '..', '.env'))

from flask import current_app # To be used within app_context
from app import create_app, db # Adjusted to import db directly if it's initialized in app.py
from models import User, Transaction # Assuming Transaction model is appropriately defined
from utils.bitcoin import get_address_from_private_key_wif, send_to_hot_wallet
# generate_bitcoin_wallet is not directly used by poller's core loop

# --- Configuration ---
# These are loaded from .env by load_dotenv() above.
# Default values are provided as fallbacks if not set in .env
DATABASE_URL = os.getenv('DATABASE_URL') # Already used by Flask app through Config
HOT_WALLET_ADDRESS = os.getenv('HOT_WALLET_ADDRESS', 'your_testnet_hot_wallet_address_here')
POLLING_INTERVAL_SECONDS = int(os.getenv('POLLING_INTERVAL_SECONDS', 60))
MIN_CONFIRMATIONS = int(os.getenv('MIN_CONFIRMATIONS', 1))
SERVICE_API_TOKEN = os.getenv('SERVICE_API_TOKEN') # Loaded from .env
INTERNAL_API_ENDPOINT_UPDATE_BALANCE = os.getenv('INTERNAL_API_ENDPOINT_UPDATE_BALANCE', "http://localhost:5000/api/internal/update_player_balance")
BLOCKCHAIN_EXPLORER_API_BASE_URL = os.getenv('BLOCKCHAIN_EXPLORER_API_URL', "https://blockstream.info/testnet/api") # e.g. https://blockstream.info/api or /testnet/api
NETWORK = os.getenv('NETWORK', 'testnet')

# --- Logging Setup ---
# Get FLASK_ENV, default to 'development' if not set
FLASK_ENV = os.getenv('FLASK_ENV', 'development')
POLLER_LOG_FILE = os.getenv('POLLER_LOG_FILE', '/var/log/casino_be_poller.log') # Ensure this path is writable by the poller process

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.handlers = [] # Clear existing handlers if any from basicConfig or re-runs

if FLASK_ENV == 'production':
    # JSON Formatter for production
    formatter = jsonlogger.JsonFormatter(
        '%(asctime)s %(levelname)s %(name)s %(module)s %(funcName)s %(lineno)d %(message)s'
    )
    # Console handler with JSON
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)
    # File handler with JSON
    try:
        file_handler = logging.FileHandler(POLLER_LOG_FILE)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        logger.info(f"Production JSON logging enabled. Log file: {POLLER_LOG_FILE}")
    except Exception as e:
        logger.error(f"Failed to configure FileHandler for production JSON logging: {e}", exc_info=True)
        # StreamHandler is already added, so logs will still go to console
else:
    # Standard text formatter for development
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)
    logger.info("Development logging enabled (text format to console).")


# --- Globals ---
# In a production system, this should be persistent (e.g., Redis, database table)
# to survive poller restarts. For this exercise, it's in-memory.
PROCESSED_TX_IDS = set()

# --- Placeholder for secure private key retrieval ---
# This is a critical security point. In a real system, this would involve a secure vault.
# For this subtask, we'll simulate it.
# A known testnet address and its WIF for demonstration purposes.
# Replace with an actual Testnet address you control if you want to test end-to-end.
# Example: tb1qtestpollerdummyaddress (fictional)
# Corresponding WIF: cTestPollerDummyPrivateKeyWIF (fictional)
KNOWN_TESTNET_ADDRESS_FOR_POLLER_SIMULATION = "tb1qtestpollerdummyaddress" # This should be an address generated by your generate_bitcoin_wallet()
KNOWN_TESTNET_WIF_FOR_POLLER_SIMULATION = "cTestPollerDummyPrivateKeyWIF" # The WIF for the above address

def get_private_key_for_address(deposit_address: str) -> str | None:
    """
    Placeholder function to simulate private key retrieval.
    WARNING: This is NOT secure and is for demonstration ONLY.
    In a real system, private keys must be stored in a secure vault (e.g., HashiCorp Vault, HSM).
    """
    logger.info(f"Attempting to retrieve private key for address: {deposit_address}")
    # Simulate checking against a known test address for the poller demo
    if NETWORK == "testnet" and deposit_address == KNOWN_TESTNET_ADDRESS_FOR_POLLER_SIMULATION:
        logger.warning(
            f"SIMULATION: Returning known testnet WIF for address {deposit_address}. "
            "This is for poller flow demonstration ONLY."
        )
        return KNOWN_TESTNET_WIF_FOR_POLLER_SIMULATION

    # For other addresses, or if not on testnet with the specific demo address:
    logger.error(
        f"CRITICAL SECURITY SIMULATION: Private key for address {deposit_address} is not available "
        "through this placeholder function. A secure vault is needed in production."
    )
    # To allow the poller to proceed for other addresses (it will fail at sweep step):
    # return None
    # For testing the poller flow further, one might temporarily return a generic test WIF,
    # but this means any actual funds sent to other deposit addresses won't be sweepable by this simulation.
    # To make it fail clearly if a real address is encountered:
    if deposit_address != KNOWN_TESTNET_ADDRESS_FOR_POLLER_SIMULATION:
         logger.error(f"No WIF configured for {deposit_address} in this simulation.")
         return None
    return None # Default to None if no match


if __name__ == '__main__':
    logger.info("Bitcoin Polling Service starting...")
    logger.info(f"Configuration: Hot Wallet: {HOT_WALLET_ADDRESS}, Interval: {POLLING_INTERVAL_SECONDS}s, Min Confirmations: {MIN_CONFIRMATIONS}")
    logger.info(f"Network: {NETWORK}, Explorer API: {BLOCKCHAIN_EXPLORER_API_BASE_URL}")
    logger.info(f"Internal Balance Update API: {INTERNAL_API_ENDPOINT_UPDATE_BALANCE}")
    if not SERVICE_API_TOKEN:
        logger.error("CRITICAL: SERVICE_API_TOKEN is not set. The poller cannot update balances.")
        exit(1)
    if not DATABASE_URL:
        logger.error("CRITICAL: DATABASE_URL is not set. Cannot connect to the database.")
        # Flask app context below will also fail, but good to check early.
        exit(1)

    # The main loop will be added in the next step.
    # For now, this confirms config loading.
    logger.info("Poller initialized. Main loop will be implemented next.")

    # Example of how app context would be used (to be filled in later)
    # app = create_app()
    # with app.app_context():
    #     logger.info("Successfully created app context for poller.")
    #     # Test DB connection (optional)
    #     try:
    #         user_count = User.query.count()
    #         logger.info(f"Successfully connected to DB. User count: {user_count}")
    #     except Exception as e:
    #         logger.error(f"Failed to connect to DB within app context: {e}", exc_info=True)

# --- API Interaction Functions ---
def update_player_balance_api(user_id: int, amount_sats: int, original_tx_id: str):
    """
    Calls the internal API to update the player's balance.
    """
    if not SERVICE_API_TOKEN:
        logger.error("SERVICE_API_TOKEN is not configured. Cannot update balance via API.")
        return False

    headers = {
        'X-Service-Token': SERVICE_API_TOKEN,
        'Content-Type': 'application/json'
    }
    payload = {
        'user_id': user_id,
        'sats_amount': amount_sats,
        'original_tx_id': original_tx_id
    }
    try:
        response = requests.post(INTERNAL_API_ENDPOINT_UPDATE_BALANCE, json=payload, headers=headers, timeout=10)
        if response.status_code == 200:
            logger.info(f"Successfully updated balance for user {user_id} via API for tx {original_tx_id}. Amount: {amount_sats}")
            return True
        else:
            logger.error(
                f"Failed to update balance for user {user_id} via API for tx {original_tx_id}. "
                f"Status: {response.status_code}, Response: {response.text}"
            )
            return False
    except requests.RequestException as e:
        logger.error(f"API call to update balance failed for user {user_id}, tx {original_tx_id}: {e}", exc_info=True)
        return False

def check_address_for_transactions(deposit_address: str, user_id: int, cycle_id: str):
    """
    Checks a given deposit address for new transactions using a blockchain explorer API.
    Processes confirmed deposits by attempting to sweep to hot wallet and updating balance.
    Includes a cycle_id for log correlation.
    """
    if not deposit_address:
        logger.warning(f"Skipping check for user {user_id} due to missing deposit address. Cycle: {cycle_id}")
        return

    explorer_url = f"{BLOCKCHAIN_EXPLORER_API_BASE_URL}/address/{deposit_address}/txs"
    logger.info(f"Checking for transactions for address: {deposit_address} (User ID: {user_id}, Cycle: {cycle_id})")

    try:
        response = requests.get(explorer_url, timeout=20) # Increased timeout for explorer API
        response.raise_for_status()  # Raise HTTPError for bad responses (4XX or 5XX)
        transactions = response.json()
    except requests.RequestException as e:
        logger.error(f"Could not fetch transactions for {deposit_address} (User ID: {user_id}, Cycle: {cycle_id}): {e}", exc_info=True)
        return
    except ValueError as e: # Includes JSONDecodeError
        logger.error(f"Could not decode JSON response for {deposit_address} (User ID: {user_id}, Cycle: {cycle_id}): {e}. Response text: {response.text[:200]}")
        return


    if not transactions:
        logger.info(f"No transactions found for address: {deposit_address} (User ID: {user_id}, Cycle: {cycle_id})")
        return

    logger.info(f"Found {len(transactions)} transactions for address {deposit_address} (User ID: {user_id}, Cycle: {cycle_id}).")

    for tx in transactions:
        txid = tx.get('txid')
        if not txid:
            logger.warning(f"Found a transaction without a txid for address {deposit_address} (User ID: {user_id}, Cycle: {cycle_id}). Skipping. TX: {tx}")
            continue

        if txid in PROCESSED_TX_IDS:
            logger.debug(f"Transaction {txid} already processed. Skipping. (User ID: {user_id}, Cycle: {cycle_id})")
            continue

        # Check confirmations (structure depends on Blockstream API)
        status = tx.get('status')
        if not status or not status.get('confirmed'):
            logger.info(f"Transaction {txid} for address {deposit_address} is not confirmed yet. Skipping. (User ID: {user_id}, Cycle: {cycle_id})")
            continue

        if status.get('block_height') is None :
             logger.warning(f"Transaction {txid} is confirmed but has no block_height. Skipping for safety. (User ID: {user_id}, Cycle: {cycle_id})")
             continue

        amount_received_sats = 0
        for vout in tx.get('vout', []):
            if vout.get('scriptpubkey_address') == deposit_address:
                amount_received_sats += vout.get('value', 0)

        if amount_received_sats <= 0:
            logger.info(f"No amount found for deposit_address {deposit_address} in tx {txid}. Skipping. (User ID: {user_id}, Cycle: {cycle_id})")
            continue

        logger.info(f"Confirmed transaction {txid} for address {deposit_address} with {amount_received_sats} sats. (User ID: {user_id}, Cycle: {cycle_id})")

        private_key_wif = get_private_key_for_address(deposit_address)
        if not private_key_wif:
            logger.error(
                f"CRITICAL: Could not retrieve private key for address {deposit_address} (User ID: {user_id}) for tx {txid}. "
                f"Cannot attempt sweep. Manual intervention likely required if this is not the KNOWN_TESTNET_ADDRESS. Cycle: {cycle_id}"
            )
            continue

        simulated_fee_sats = 1000 # Placeholder fee

        sweep_txid = send_to_hot_wallet(
            private_key_wif=private_key_wif,
            amount_sats=amount_received_sats,
            hot_wallet_address=HOT_WALLET_ADDRESS,
            fee_sats=simulated_fee_sats
        )

        if sweep_txid:
            logger.info(f"Successfully simulated sweep of {amount_received_sats} sats from {deposit_address} to {HOT_WALLET_ADDRESS}. Sweep TXID: {sweep_txid}. (User ID: {user_id}, Cycle: {cycle_id})")
            # Pass cycle_id to update_player_balance_api if it were enhanced to log it or include in API call
            if update_player_balance_api(user_id, amount_received_sats, txid): # cycle_id could be logged inside this func if modified
                logger.info(f"Successfully processed deposit {txid} for user {user_id}, amount {amount_received_sats}. (Cycle: {cycle_id})")
                PROCESSED_TX_IDS.add(txid)
            else:
                logger.error(
                    f"Failed to update balance via API for user {user_id} after successful sweep of tx {txid}. Cycle: {cycle_id}. "
                    "This is a critical issue requiring manual reconciliation."
                )
        else:
            logger.error(
                f"Failed to simulate sweep for tx {txid} from address {deposit_address} (User ID: {user_id}). Cycle: {cycle_id}. "
                "Deposit will not be credited automatically at this time."
            )

def poll_deposits():
    """
    Main polling function to check for new deposits.
    Runs within a Flask app context.
    """
    cycle_id = str(uuid.uuid4())
    logger.info(f"Starting polling cycle ID: {cycle_id}")

    app = create_app()
    with app.app_context():
        logger.info(f"Polling for new Bitcoin deposits... Cycle: {cycle_id}")
        try:
            users_with_wallets = User.query.filter(User.deposit_wallet_address.isnot(None)).all()
            if not users_with_wallets:
                logger.info(f"No users with deposit wallets found to poll. Cycle: {cycle_id}")
                return

            logger.info(f"Found {len(users_with_wallets)} users with deposit wallets. Cycle: {cycle_id}")
            for user in users_with_wallets:
                if user.deposit_wallet_address:
                    check_address_for_transactions(user.deposit_wallet_address, user.id, cycle_id)
                else:
                    logger.warning(f"User ID {user.id} listed with wallets but has no deposit_wallet_address. Skipping. Cycle: {cycle_id}")
        except Exception as e:
            logger.error(f"Error during polling cycle {cycle_id}: {e}", exc_info=True)
        finally:
            logger.info(f"Polling cycle {cycle_id} finished.")


if __name__ == '__main__':
    logger.info("Bitcoin Polling Service starting...")
    logger.info(f"Configuration: Hot Wallet: {HOT_WALLET_ADDRESS}, Interval: {POLLING_INTERVAL_SECONDS}s, Min Confirmations: {MIN_CONFIRMATIONS}")
    logger.info(f"Network: {NETWORK}, Explorer API: {BLOCKCHAIN_EXPLORER_API_BASE_URL}")
    logger.info(f"Internal Balance Update API: {INTERNAL_API_ENDPOINT_UPDATE_BALANCE}")

    if not SERVICE_API_TOKEN:
        logger.error("CRITICAL: SERVICE_API_TOKEN is not set. Poller cannot update balances.")
        exit(1)
    if not DATABASE_URL: # Check if DATABASE_URL (used by create_app for SQLALCHEMY_DATABASE_URI) is available
        logger.error("CRITICAL: DATABASE_URL is not set. Cannot connect to the database.")
        exit(1)
    if not HOT_WALLET_ADDRESS or "your_testnet_hot_wallet_address_here" in HOT_WALLET_ADDRESS :
        logger.warning("WARNING: HOT_WALLET_ADDRESS is not configured or is using a default placeholder.")
        # Allow to run for testing, but this would be an error in prod.

    logger.info("Poller initialized. Starting main loop...")
    while True:
        try:
            poll_deposits()
        except Exception as e:
            logger.error(f"Unhandled exception in main polling loop: {e}", exc_info=True)
            # Avoid rapid-fire restarts on persistent errors in the loop itself
            # (though poll_deposits has its own try/except)
        logger.info(f"Sleeping for {POLLING_INTERVAL_SECONDS} seconds...")
        time.sleep(POLLING_INTERVAL_SECONDS)
